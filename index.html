<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="keywords" content="Android">
<meta property="og:type" content="website">
<meta property="og:title" content="Coding and Learning">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Coding and Learning">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coding and Learning">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Coding and Learning</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coding and Learning</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">oubindo的技术与生活博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/05/一篇文章深入gradle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/05/一篇文章深入gradle/" itemprop="url">一篇文章深入gradle（上篇）:依赖机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-05T21:30:44+08:00">
                2019-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一篇文章深入gradle（上篇）-依赖机制"><a href="#一篇文章深入gradle（上篇）-依赖机制" class="headerlink" title="一篇文章深入gradle（上篇）:依赖机制"></a>一篇文章深入gradle（上篇）:依赖机制</h2><p>Hello，各位朋友们，小笨鸟又和你们见面啦。不同于网上泛泛而谈的入门文章只停留在“怎么用”的层次，本篇文章从源码角度去理解gradle。当然，如果你没有看过我的前一篇文章《一篇文章基本看懂gradle》，还是建议你先看一下，本篇文章的很多知识点会在上篇文章的基础上展开。</p>
<p>本篇文章会比较深入，需要费一些脑筋和精力才能理解。建议跟着我的行文思路一步一步理解。本文的篇幅会比较长。阅读大概需要花费半个小时。阅读本文将会了解:</p>
<ul>
<li>gradle构建Lifecycle</li>
<li>gradle Extension和Plugin</li>
<li>gradle依赖实现，Configuration</li>
</ul>
<p>其中gradle依赖将会是本文的重点。本来之前还想把artifact也讲解到，但是发现篇幅已经很长了，所以就一篇文章拆成两篇吧。</p>
<h2 id="gradle构建Lifecycle"><a href="#gradle构建Lifecycle" class="headerlink" title="gradle构建Lifecycle"></a>gradle构建Lifecycle</h2><p>Lifecycle的概念我们在上一篇文章讲Project的时候也讲到过。在这篇文章中，我们会再简单讲一讲作为引入。</p>
<p>正如<a href="https://docs.gradle.org/current/userguide/build_lifecycle.html" target="_blank" rel="noopener">官网</a>所说，gradle构建流程总共为三个阶段：</p>
<ul>
<li>初始化阶段：在这个阶段中settings.gradle是主角，gradle会把settings.gradle中的配置代理给Settings类。主要负责的是判断哪些module需要参与到构建中，然后根据这些module的设置初始化他们的delegate对象Project。注意，Project对象是在初始化阶段生成的。</li>
<li>配置阶段：配置阶段的任务是执行各项目下的build.gradle，完成Project对象的配置，并且构造Task任务依赖关系图<code>TaskExectionGraph</code>以便在执行阶段按照依赖关系执行Task。</li>
<li>执行阶段：执行阶段会根据你命令行输入的Task，按照依赖关系通过调用<code>gradle taskname</code>进行执行。</li>
</ul>
<p>值得一提的是，我们可以通过多种方式对project构建阶段进行监控和处理。如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下为Project的方法</span></span><br><span class="line">afterEvaluate(closure)，afterEvaluate(action)</span><br><span class="line">beforeEvaluate(closure)，beforeEvaluate(action)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为gradle提供的生命周期回调</span></span><br><span class="line">afterProject(closure)，afterProject(action)</span><br><span class="line">beforeProject(closure)，beforeProject(action)</span><br><span class="line">buildFinished(closure)，buildFinished(action)</span><br><span class="line">projectsEvaluated(closure)，projectsEvaluated(action)</span><br><span class="line">projectsLoaded(closure)，projectsLoaded(action)</span><br><span class="line">settingsEvaluated(closure)，settingsEvaluated(action)</span><br><span class="line">addBuildListener(buildListener)</span><br><span class="line">addListener(listener)</span><br><span class="line">addProjectEvaluationListener(listener)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Task也有这种方法</span></span><br><span class="line">afterTask​(Closure closure)</span><br><span class="line">beforeTask(Closure closure)</span><br><span class="line"><span class="comment">//任务准备好后调用</span></span><br><span class="line">whenReady(Closure closure)</span><br></pre></td></tr></table></figure></p>
<p>那么知道这样的构建流程我们可以怎么使用呢？我们可以进行监控，或者是动态的根据需要去控制project和task的构建执行。比如为了加快编译速度，我们去掉一些测试的task。就可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gradle.taskGraph.whenReady &#123;</span><br><span class="line">        tasks.each &#123; task -&gt;</span><br><span class="line">            if (task.name.contains(&quot;Test&quot;)) &#123;</span><br><span class="line">                task.enabled = false</span><br><span class="line">            &#125; else if (task.name == &quot;mockableAndroidJar&quot;) &#123;</span><br><span class="line">                task.enabled = false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Extension和Plugin"><a href="#Extension和Plugin" class="headerlink" title="Extension和Plugin"></a>Extension和Plugin</h2><p>Extension和Plugin都是我们日常开发中经常有讲到的东西。上一篇文章中我们讲到了build.gradle中的闭包都是有一个Delegate代理的，这个代理对象可以接受闭包中的参数传递给自己来使用，那么这个代理是啥呢？其实就是我们这里要说的Extension。</p>
<p>1.Extension通俗来讲其实就是一个普通的java bean。里面存放一些参数。使用需要借助于ExtensionContainer来进行创建。举个栗子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    String message = <span class="string">"empty"</span></span><br><span class="line">    String greeter = <span class="string">"none"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来在gradle文件中去使用project.extensions(也就是ExtensionContainer)来进行创建。</span></span><br><span class="line">def extension = project.extensions.create(<span class="string">"cyMessage"</span>, Message)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再写个task来进行验证</span></span><br><span class="line">project.task(<span class="string">'sendMessage'</span>) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"$&#123;extension.message&#125; from $&#123;extension.greeter&#125;"</span></span><br><span class="line">        println project.cyMessage.message + <span class="string">"from $&#123;extension.greeter&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.Plugin插件<br>讲完了Extension，我们可能就会疑惑了。因为我们在build.gradle中并没有看到这些javabean和extension添加的操作啊，那么这些代码是在哪里写的呢？这时候我们就要引入Plugin的概念了，也就是你看到的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin &apos;com.android.application&apos;</span><br></pre></td></tr></table></figure></p>
<p>这个玩意了。这个就是Android Application的插件。android相关的Extension都是定义在这个插件中的。<br>有些同学可能对插件不是很理解，为什么需要这个东西。其实大家可以思考一下，gradle只是一个通用的构建工具。在他上层可能有各种应用，比如java，比如Android，甚至可能是未来的鸿蒙。那么这些应用对gradle肯定会有不同的扩展，又肯定不能把这些扩展直接放在gradle中。所以在上层添加插件就是个好选择，需要什么扩展就选什么插件。<br>Android开发中常见的插件有三种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apply plugin &apos;com.android.application&apos;   // AppPlugin,  主module才能引用</span><br><span class="line">apply plugin &apos;com.android.library&apos;    // LibraryPlugin, 普通的android module引用</span><br><span class="line">apply plugin &apos;java&apos;                           // java module的引用</span><br></pre></td></tr></table></figure></p>
<p>插件的其它知识不是本篇文章的重点，网上这方面的文章很多，大家可以自行学习。我们根据现在掌握的知识就要去探索gradle更深层次的知识啦。</p>
<h2 id="gradle依赖实现"><a href="#gradle依赖实现" class="headerlink" title="gradle依赖实现"></a>gradle依赖实现</h2><p>这两篇文章截止到现在，gradle构建相关的流程我们基本都走通了。但是有个很重要的组件我们没有去分析。就是依赖管理。我们前一篇文章也讲到了，依赖管理是gradle的一个很重要的特性，方便我们进行代码复用。那么我们这一部分就专门讲一讲依赖管理到底是怎么实现的。</p>
<p>首先我们还是看看基本的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)</span><br><span class="line">    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;</span><br><span class="line">    api  &apos;com.android.support:appcompat-v7:26.1.0&apos;</span><br><span class="line">    implementation project(&apos;:test&apos;)</span><br><span class="line">    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;</span><br><span class="line">    annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.4.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，一般有三种三方库类型，第一种是二进制文件，fileTree指向这个文件夹下的所有jar文件，第二种是三方库的string坐标形式，第三种是project的形式。<br>当然，我们也会知道，代码中的implementation和api两种引用方式是有区别的。implement的依赖是不能传递的，但是api是可以的。</p>
<p>我们在之前的研发中，可能没有去考虑深层次的这三种三方库类型，两种引用方式的原因。当我们按照上一篇中所说的代理模式去DependencyHandler中找implement, api等相关方法的时候，却发现，好像并没有定义这些方法，那么这是怎么回事呢？如果没有定义，是不是可以随便定义一种引用方式呢？带着问题我们往下面看</p>
<h3 id="1-源码阅读姿势"><a href="#1-源码阅读姿势" class="headerlink" title="1.源码阅读姿势"></a>1.源码阅读姿势</h3><p>首先我们还是先介绍一下阅读gradle源码的方式。我尝试了很多种方式，发现还是Android studio阅读起来最舒服，然后找到了一种方法。就是可以建一个gradle的demo，然后建一个module，把除了build.gradle以外的东西全部删掉。然后拷贝下面的代码进去。这样就能看到源码了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply plugin &apos;java&apos;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">     compile gradleApi()</span><br><span class="line">     compile &apos;xxxx&apos;  // 填入你gradle的版本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h3><h4 id="2-1-methodmissing"><a href="#2-1-methodmissing" class="headerlink" title="2.1 methodmissing"></a>2.1 methodmissing</h4><p>首先我们先介绍一个groovy语言的特性：methodmissing。大家可以参考<a href="http://groovy-lang.org/metaprogramming.html#_methodmissing" target="_blank" rel="noopener">官网</a><br>简单来说就是当我们预先在一个类中定义一个methodmissing方法。然后在这个类的对象上调用之前没有定义过的方法时，这个方法就会降级(fallback)到它所定义的methodmissing方法上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class GORM &#123;</span><br><span class="line"></span><br><span class="line">   def dynamicMethods = [...] // an array of dynamic methods that use regex</span><br><span class="line"></span><br><span class="line">   def methodMissing(String name, args) &#123;</span><br><span class="line">       def method = dynamicMethods.find &#123; it.match(name) &#125;</span><br><span class="line">       if(method) &#123;</span><br><span class="line">          GORM.metaClass.&quot;$name&quot; = &#123; Object[] varArgs -&gt;</span><br><span class="line">             method.invoke(delegate, name, varArgs)</span><br><span class="line">          &#125;</span><br><span class="line">          return method.invoke(delegate,name, args)</span><br><span class="line">       &#125;</span><br><span class="line">       else throw new MissingMethodException(name, delegate, args)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert new GORM().methodA(1) == resultA</span><br></pre></td></tr></table></figure></p>
<p>如图，当我们调用methodA时，因为这个方法没有定义，就会转到methodmissing方法上，并且会把这个方法的名字methodA和它的参数一起传到methodmissing，这样如果dynamicMethod里面有定义methodA的话，这个方法就能执行了。这就是methodmissing的妙用。</p>
<p>为什么需要这种机制呢？我理解这还是为了扩展性。dependencies是gradle自身的功能。它不能完全的总括所有上层应用可能会有的引用方式。每种插件都可能增加引用的方式，为了扩展性考虑，必须采用这种methodmissing的特性，把这些引用交给插件处理。比如Android的implement, api, annotationProcessor等。</p>
<h4 id="2-2-Configuration"><a href="#2-2-Configuration" class="headerlink" title="2.2 Configuration"></a>2.2 Configuration</h4><p>在往下面讲解前，我们先了解一下<a href="https://docs.gradle.org/current/userguide/managing_dependency_configurations.html" target="_blank" rel="noopener">Configuration</a>的一些知识。<br>按照官网所说：</p>
<blockquote>
<p>Every dependency declared for a Gradle project applies to a specific scope. For example some dependencies should be used for compiling source code whereas others only need to be available at runtime. Gradle represents the scope of a dependency with the help of a Configuration. Every configuration can be identified by a unique name.</p>
</blockquote>
<p>也就是说，Configuration定义了依赖在编译和运行时候的不同范围, 每个Configuration都有name来区分。比如android常见的两种依赖方式implementation和api。<br><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190904002104.png" alt="">。</p>
<h4 id="2-3-依赖的识别"><a href="#2-3-依赖的识别" class="headerlink" title="2.3 依赖的识别"></a>2.3 依赖的识别</h4><p>gradle中使用MethodMixIn这个接口来实现methodmissing的能力。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MethodMixIn</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodMixIn</span> </span>&#123;</span><br><span class="line">    <span class="function">MethodAccess <span class="title">getAdditionalMethods</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodAccess</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true when this object is known to have a method with the given name that accepts the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that not every method is known. Some methods may require an attempt invoke it in order for them to be discovered.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasMethod</span><span class="params">(String name, Object... arguments)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invokes the method with the given name and arguments.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">DynamicInvokeResult <span class="title">tryInvokeMethod</span><span class="params">(String name, Object... arguments)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里的methodmissing主要是在找不到这个方法的时候去返回一个MethodAccess，MethodAccess中去判断是否存在以及动态执行这个method。</p>
<p>接下来我们看DependencyHandler的实现类DefaultDependencyHandler。这个类实现了MethodMixIn接口，返回的是一个DynamicAddDependencyMethods对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultDependencyHandler.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultDependencyHandler</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.dynamicMethods = <span class="keyword">new</span> DynamicAddDependencyMethods(configurationContainer, <span class="keyword">new</span> DefaultDependencyHandler.DirectDependencyAdder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodAccess <span class="title">getAdditionalMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dynamicMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以其实就是返回了一个DynamicAddDependencyMethods去加以判断。那么毫无疑问要在这个类中进行判断和执行具体方法。接下来我们看看这个类中是怎么处理的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">DynamicAddDependencyMethods(ConfigurationContainer configurationContainer, DynamicAddDependencyMethods.DependencyAdder dependencyAdder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.configurationContainer = configurationContainer;</span><br><span class="line">    <span class="keyword">this</span>.dependencyAdder = dependencyAdder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMethod</span><span class="params">(String name, Object... arguments)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arguments.length != <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.configurationContainer.findByName(name) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DynamicInvokeResult <span class="title">tryInvokeMethod</span><span class="params">(String name, Object... arguments)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arguments.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> DynamicInvokeResult.notFound();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Configuration configuration = (Configuration)<span class="keyword">this</span>.configurationContainer.findByName(name);</span><br><span class="line">        <span class="keyword">if</span> (configuration == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> DynamicInvokeResult.notFound();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;?&gt; normalizedArgs = CollectionUtils.flattenCollections(arguments);</span><br><span class="line">            <span class="keyword">if</span> (normalizedArgs.size() == <span class="number">2</span> &amp;&amp; normalizedArgs.get(<span class="number">1</span>) <span class="keyword">instanceof</span> Closure) &#123;</span><br><span class="line">                <span class="keyword">return</span> DynamicInvokeResult.found(<span class="keyword">this</span>.dependencyAdder.add(configuration, normalizedArgs.get(<span class="number">0</span>), (Closure)normalizedArgs.get(<span class="number">1</span>)));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizedArgs.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> DynamicInvokeResult.found(<span class="keyword">this</span>.dependencyAdder.add(configuration, normalizedArgs.get(<span class="number">0</span>), (Closure)<span class="keyword">null</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Iterator var5 = normalizedArgs.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">                    Object arg = var5.next();</span><br><span class="line">                    <span class="keyword">this</span>.dependencyAdder.add(configuration, arg, (Closure)<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> DynamicInvokeResult.found();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这个类的两个要点：<br>1.判断Configuration有无：通过外部传入的ConfigurationContainer来判断是否存在这个方法。<strong>这样我们可以联想到，这个ConfigurationContainer肯定是每个平台Plugin自己传入的，必须是已定义的才能使用</strong>。比如android就添加了implementation, api等。如果你想查看Configuration在gradle源码中的初始化和配置，可以查看VariantDependencies这个类。</p>
<p>2.执行方法：真正的执行方法会根据参数来判断，比如我们常见的一个参数的引用形式，还有一个参数+一个闭包的形式，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'com.zhyea:ar4j:1.0'</span>) &#123;</span><br><span class="line">		exclude <span class="keyword">module</span>: <span class="string">'cglib'</span> <span class="comment">//by artifact name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种类型的引用。当在ConfigurationContainer中找到了这个引用方式(以下都称Configuration)时，就会返回一个DynamicInvokeResult。具体这个类的作用我们后面再看，我们先看他们都做了一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.dependencyAdder.add(configuration, arg, (Closure)<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>的操作，这个操作是做了些什么呢，我们继续往下跟就会发现，其实还是调用了DefaultDependencyHandler的doAdd方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultDependencyHandler.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectDependencyAdder</span> <span class="keyword">implements</span> <span class="title">DependencyAdder</span>&lt;<span class="title">Dependency</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DirectDependencyAdder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dependency <span class="title">add</span><span class="params">(Configuration configuration, Object dependencyNotation, @Nullable Closure configureAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DefaultDependencyHandler.<span class="keyword">this</span>.doAdd(configuration, dependencyNotation, configureAction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Dependency <span class="title">doAdd</span><span class="params">(Configuration configuration, Object dependencyNotation, Closure configureClosure)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dependencyNotation <span class="keyword">instanceof</span> Configuration) &#123;</span><br><span class="line">        Configuration other = (Configuration)dependencyNotation;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.configurationContainer.contains(other)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Currently you can only declare dependencies on configurations from the same project."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            configuration.extendsFrom(<span class="keyword">new</span> Configuration[]&#123;other&#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Dependency dependency = <span class="keyword">this</span>.create(dependencyNotation, configureClosure);</span><br><span class="line">        configuration.getDependencies().add(dependency);</span><br><span class="line">        <span class="keyword">return</span> dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里会先判断dependencyNotation是否是Configuration，如果存在的话，就让当前的configuration继承dependencyNotation，也就是所有添加到dependencyNotation的依赖都会添加到configuration中。</p>
<p>这里可能有些朋友就会疑惑了，为啥还要对dependencyNotation判断呢？这个主要是为了处理嵌套的情况。比如implementation project(path: ‘:projectA’, configuration: ‘configA’)这种类型的引用。有兴趣可以看看上面的<code>CollectionUtils.flattenCollections(arguments)</code>方法。</p>
<p>总结一下，这个过程就是借助gradle的MethodMixIn接口，将所有未定义的引用方法转到getAdditionalMethods方法上来，在这个方法里面判断Configuration是否存在，如果存在的话就生成Dependency。</p>
<h4 id="2-4-依赖的创建"><a href="#2-4-依赖的创建" class="headerlink" title="2.4 依赖的创建"></a>2.4 依赖的创建</h4><p>可以看到上面过程的最后，是DefaultDependencyHandler调用了create方法创建出了一个Dependency。我们继续来分析创建Dependency的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultDependencyHandler.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dependency <span class="title">create</span><span class="params">(Object dependencyNotation, Closure configureClosure)</span> </span>&#123;</span><br><span class="line">    Dependency dependency = <span class="keyword">this</span>.dependencyFactory.createDependency(dependencyNotation);</span><br><span class="line">    <span class="keyword">return</span> (Dependency)ConfigureUtil.configure(configureClosure, dependency);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultDependencyFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dependency <span class="title">createDependency</span><span class="params">(Object dependencyNotation)</span> </span>&#123;</span><br><span class="line">    Dependency dependency = (Dependency)<span class="keyword">this</span>.dependencyNotationParser.parseNotation(dependencyNotation);</span><br><span class="line">    <span class="keyword">this</span>.injectServices(dependency);</span><br><span class="line">    <span class="keyword">return</span> dependency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最终是调用了dependencyNotationParser来parse这个dependencyNotation。而这里的dependencyNotationParser其实就是DependencyNotationParser这个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyNotationParser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NotationParser&lt;Object, Dependency&gt; <span class="title">parser</span><span class="params">(Instantiator instantiator, DefaultProjectDependencyFactory dependencyFactory, ClassPathRegistry classPathRegistry, FileLookup fileLookup, RuntimeShadedJarFactory runtimeShadedJarFactory, CurrentGradleInstallation currentGradleInstallation, Interner&lt;String&gt; stringInterner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NotationParserBuilder.toType(Dependency.class)</span><br><span class="line">        .fromCharSequence(<span class="keyword">new</span> DependencyStringNotationConverter(instantiator, DefaultExternalModuleDependency.class, stringInterner))</span><br><span class="line">        .converter(<span class="keyword">new</span> DependencyMapNotationConverter(instantiator, DefaultExternalModuleDependency.class))</span><br><span class="line">        .fromType(FileCollection.class, <span class="keyword">new</span> DependencyFilesNotationConverter(instantiator))</span><br><span class="line">        .fromType(Project.class, <span class="keyword">new</span> DependencyProjectNotationConverter(dependencyFactory))</span><br><span class="line">        .fromType(ClassPathNotation.class, <span class="keyword">new</span> DependencyClassPathNotationConverter(instantiator, classPathRegistry, fileLookup.getFileResolver(), runtimeShadedJarFactory, currentGradleInstallation))</span><br><span class="line">        .invalidNotationMessage(<span class="string">"Comprehensive documentation on dependency notations is available in DSL reference for DependencyHandler type."</span>).toComposite();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从里面我们看到了FileCollection，Project，ClassPathNotation三个类，是不是感觉和我们的三种三方库资源形式很对应？其实这三种资源形式的解析就是用这三个类进行的。DependencyNotationParser就是整合了这些转换器，成为一个综合的转换器。其中，</p>
<ul>
<li>DependencyFilesNotationConverter将FileCollection解析为SelfResolvingDependency，也就是implementation fileTree(include: [‘*.jar’], dir: ‘libs’)这种形式。</li>
<li>DependencyProjectNotationConverter将Project解析为ProjectDependency。也就是implementation project(‘:projectA’)</li>
<li>DependencyClassPathNotationConverter将ClassPathNotation转成SelfResolvingDependency。也就是implementation ‘xxx’这种。</li>
</ul>
<p>这三种方式具体的解析方法大家可以自行阅读源码，不是本文重点。所以除了Project会被解析为ProjectDependency以外，其他的都是SelfResolvingDependency。其实ProjectDependency是SelfResolvingDependency的子类。他们的关系可以从SelfResolvingDependency的代码注释中看出。</p>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190904101030.png" alt=""></p>
<h4 id="2-5-ProjectDependency"><a href="#2-5-ProjectDependency" class="headerlink" title="2.5 ProjectDependency"></a>2.5 ProjectDependency</h4><p>接下来讲讲ProjectDependency.一个常见的Project引用如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation project(‘:projectA’)</span><br></pre></td></tr></table></figure></p>
<p>这里的implementation我们已经知道是插件添加的扩展，不是gradle自带的。那project呢？这个就是gradle自带的了。delegate是DependencyHandler的project方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultDependencyHandler.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dependency <span class="title">project</span><span class="params">(Map&lt;String, ?&gt; notation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dependencyFactory.createProjectDependencyFromMap(<span class="keyword">this</span>.projectFinder, notation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultDependencyFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProjectDependency <span class="title">createProjectDependencyFromMap</span><span class="params">(ProjectFinder projectFinder, Map&lt;? extends String, ? extends Object&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.projectDependencyFactory.createFromMap(projectFinder, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProjectDependencyFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProjectDependency <span class="title">createFromMap</span><span class="params">(ProjectFinder projectFinder, Map&lt;? extends String, ?&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ProjectDependency)NotationParserBuilder.toType(ProjectDependency.class).converter(<span class="keyword">new</span> ProjectDependencyFactory.ProjectDependencyMapNotationConverter(projectFinder, <span class="keyword">this</span>.factory)).toComposite().parseNotation(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProjectDependencyMapNotationConverter.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ProjectDependency <span class="title">parseMap</span><span class="params">(@MapKey(<span class="string">"path"</span>)</span> String path, @Optional @<span class="title">MapKey</span><span class="params">(<span class="string">"configuration"</span>)</span> String configuration) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.factory.create(<span class="keyword">this</span>.projectFinder.getProject(path), configuration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultProjectDependencyFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProjectDependency <span class="title">create</span><span class="params">(ProjectInternal project, String configuration)</span> </span>&#123;</span><br><span class="line">    DefaultProjectDependency projectDependency = (DefaultProjectDependency)<span class="keyword">this</span>.instantiator.newInstance(DefaultProjectDependency.class, <span class="keyword">new</span> Object[]&#123;project, configuration, <span class="keyword">this</span>.projectAccessListener, <span class="keyword">this</span>.buildProjectDependencies&#125;);</span><br><span class="line">    projectDependency.setAttributesFactory(<span class="keyword">this</span>.attributesFactory);</span><br><span class="line">    projectDependency.setCapabilityNotationParser(<span class="keyword">this</span>.capabilityNotationParser);</span><br><span class="line">    <span class="keyword">return</span> projectDependency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，传入的project最终传递给了ProjectDependencyMapNotationConverter。先去查找这个project，然后通过factory去create ProjectDependency对象，当然这里也有考虑到Configuration的影响, 最终是产生了一个DefaultProjectDependency。这就是ProjectDependency的产生过程。</p>
<h4 id="2-6-依赖的体现"><a href="#2-6-依赖的体现" class="headerlink" title="2.6 依赖的体现"></a>2.6 依赖的体现</h4><p>看到这里，大家可以已经理解了不同的依赖的解析方式，但是可能还是不理解依赖到底是一个什么东西。<strong>其实依赖库并不是依赖三方库的源代码，而是依赖三方库的产物，产物又是通过一系列的Task执行产生的</strong>。也就是说，projectA依赖projectB，那么A就拥有了对于B的产物的所有权。关于产物我们等后面再介绍。先了解一下Configuration对于产物有一些什么支持。<br>我们看Configuration的代码， 可以发现他继承了FileCollection接口，而FileCollection又继承了Buildable接口。这个接口有啥用呢，用处大得很。先看<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Buildable.html" target="_blank" rel="noopener">官网</a>介绍</p>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190905001835.png" alt=""></p>
<p>Buildable表示着很多Task对象生成的产物。它里面只有一个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Buildable</span> </span>&#123;</span><br><span class="line">    <span class="function">TaskDependency <span class="title">getBuildDependencies</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看看DefaultProjectDependency的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultProjectDependency.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TaskDependencyInternal <span class="title">getBuildDependencies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultProjectDependency.TaskDependencyImpl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskDependencyImpl</span> <span class="keyword">extends</span> <span class="title">AbstractTaskDependency</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TaskDependencyImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitDependencies</span><span class="params">(TaskDependencyResolveContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DefaultProjectDependency.<span class="keyword">this</span>.buildProjectDependencies) &#123;</span><br><span class="line">            DefaultProjectDependency.<span class="keyword">this</span>.projectAccessListener.beforeResolvingProjectDependency(DefaultProjectDependency.<span class="keyword">this</span>.dependencyProject);</span><br><span class="line">            Configuration configuration = DefaultProjectDependency.<span class="keyword">this</span>.findProjectConfiguration();</span><br><span class="line">            context.add(configuration);</span><br><span class="line">            context.add(configuration.getAllArtifacts());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">findProjectConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConfigurationContainer dependencyConfigurations = <span class="keyword">this</span>.getDependencyProject().getConfigurations();</span><br><span class="line">    String declaredConfiguration = <span class="keyword">this</span>.getTargetConfiguration();</span><br><span class="line">    Configuration selectedConfiguration = dependencyConfigurations.getByName((String)GUtil.elvis(declaredConfiguration, <span class="string">"default"</span>));</span><br><span class="line">    <span class="keyword">if</span> (!selectedConfiguration.isCanBeConsumed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationNotConsumableException(<span class="keyword">this</span>.dependencyProject.getDisplayName(), selectedConfiguration.getName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> selectedConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，其实就是在解析每个依赖的时候，如果指定了ConfigurationContainer中声明好的Configuration，比如implementation, api等，那就返回这个Configuration，否则就返回default。拿到这个Configuration之后，做了这个操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.add(configuration);</span><br><span class="line">context.add(configuration.getAllArtifacts());</span><br></pre></td></tr></table></figure></p>
<p>这里的context是一个TaskDependencyResolveContext，它的add方法可以添加能contribute tasks to the result的对象，比如Task，TaskDependencies，Buildable等，这些类型都能为产生结果贡献Task(前面我们说到了就是靠Task产生产物的嘛)。 </p>
<p>这里context把configuration和configuration.getAllArtifacts()加入，都是作为Buildable而加入。区别是configuration.getAllArtifacts()获取的是DefaultPublishArtifactSet对象。接下来看看DefaultPublishArtifactSet是怎么实现Buildable的方法的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TaskDependency <span class="title">getBuildDependencies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.builtBy;   <span class="comment">// 这里的builtBy是下面的ArtifactsTaskDependency对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ArtifactsTaskDependency</span> <span class="keyword">extends</span> <span class="title">AbstractTaskDependency</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ArtifactsTaskDependency</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitDependencies</span><span class="params">(TaskDependencyResolveContext context)</span> </span>&#123;</span><br><span class="line">        Iterator var2 = DefaultPublishArtifactSet.<span class="keyword">this</span>.iterator();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">            PublishArtifact publishArtifact = (PublishArtifact)var2.next();</span><br><span class="line">            context.add(publishArtifact);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现果然和DefaultPublishArtifactSet的名字一样，是作为set把里面包含的PublishArtifact对象逐个的放入context中。</p>
<h4 id="2-7-总结"><a href="#2-7-总结" class="headerlink" title="2.7 总结"></a>2.7 总结</h4><p>我们在这一小节中分析了不同的依赖方式的区别，告诉了大家Configuration是什么东西，也告诉了大家依赖到底是怎么产生和起作用的。这样大家在日常开发中就更能知其所以然了。总结一下就是说</p>
<ul>
<li>implementation等都是通过methodmissing机制，被插件解析成不同的Configuration，所以要预定义。</li>
<li>我们不同的依赖声明，将会被不同的转化器Parser进行转换。project依赖会被转换为ProjectDependency，其余的会被解析成可自解析的SelfResolvingDependencies。</li>
<li>project依赖最终是Task和产物artifact的依赖。</li>
</ul>
<p>那么Task和产物又是一种什么关系呢？这个就涉及到更深层次了。本文篇幅有限，放在下一篇再分析吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是从Extension和Plugin引入，主要讲解了gradle依赖的原理和解析机制，然后抛下了一个疑问：产物artifacts是怎么和依赖扯上关系的呢？这个问题我们等下一篇《一篇文章深入gradle（下篇）:Artifacts》再解答</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/30/一篇文章看懂gradle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/30/一篇文章看懂gradle/" itemprop="url">一篇文章基本看懂gradle</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-30T10:09:44+08:00">
                2019-08-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一篇文章基本看懂gradle"><a href="#一篇文章基本看懂gradle" class="headerlink" title="一篇文章基本看懂gradle"></a>一篇文章基本看懂gradle</h1><p>Hi，大家好啊。笨鸟之旅已经很久都没有更新了，感谢大家这么久以来还把我留在列表里。这么久以来不更新的原因主要是我本人进入了一个迷茫期，对于工作和生活都提不起兴致来。加上每天工作的时间太长，一回家就瘫在床上了。这也导致了很久之前的文章计划一直都搁浅，做的计划一次一次的delay。于是生活进入了一个负循环。但是生活还是要向上看，还是要坚持去努力做点事情，努力去变得更好，所以我又来了。以后一定会努力的学习，努力的发文。</p>
<p>这段时间来学习了gradle，也体会到了gradle从初步理解到基本熟悉，再到深入源码这样一个过程中的一些曲折。这篇文章主要是gradle的基础知识篇。看完这篇文章，你可以：</p>
<ul>
<li>清楚gradle的定义和解决的痛点</li>
<li>基本理解Android gradle的运作机制</li>
<li>基本理解gradle的大部分语法</li>
<li>学会基本的groovy开发</li>
</ul>
<p>如果你想关注gradle更深入的一些知识，请继续关注后续gradle文章。</p>
<h2 id="what-is-gradle"><a href="#what-is-gradle" class="headerlink" title="what is gradle?"></a>what is gradle?</h2><p>先来看一段维基百科上对于gradle的解释。</p>
<blockquote>
<p>Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。当前其支持的语言限于Java、Groovy和Scala，计划未来将支持更多的语言。</p>
</blockquote>
<p>可能刚接触gradle的同学都不是很了解gradle的这个定义。可能就只会跟着网上的教程copy一点配置，但是不理解这些配置背后的原理。那么怎么来理解这句话呢，我们可以把握到三个要点：首先，它是一种<code>构建工具</code>，其次，gradle是<code>基于maven概念</code>的，最后，使用<code>groovy</code>这种语言来声明。要理解这几句话，我们先考虑几个场景。</p>
<p>1.<code>渠道管理</code>：国内手机市场有大大小小数十个，大的手机厂商也有五六个，每个厂商可能又有不同的定制rom。如果我们要为不同市场和厂商进行适配，那就需要写这样的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(isHuawei) &#123;</span><br><span class="line">    // dosomething</span><br><span class="line">&#125; else if(isOppo) &#123;</span><br><span class="line">    // dosomething</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的话，繁琐不说，对单个手机而言大量的无用代码被编译进apk中，包体积和运行速度都会受影响。为了解决这个问题，gradle引进了productFlavor和buildType的能力，能根据情况来进行打包。所以说他是一个<code>自动化构建工具</code>。可以看<a href="https://developer.android.com/studio/build?hl=zh-cn" target="_blank" rel="noopener">官方文档</a></p>
<p>2.<code>依赖管理</code>：我们通常会在项目中引入各种三方库进行代码复用。比如，直接手动把jar或者aar copy到项目中，然后添加依赖。这种方法缺陷很明显，首先配置和删除流程很繁琐，其次，同一个jar可能会被多个项目所引用，导致不知不觉就copy了多个jar。最后，版本管理艰难。为了解决这个问题，gradle是基于maven仓库，配置和删除的时候仅需要对仓库的坐标进行操作，所有的库都会被gradle统一管理，大多数情况下每个库只会有一个版本存在于项目中，并且每个库只会有一个副本存在于项目中。</p>
<p>所以gradle其实不是什么神秘的东西，只是基于某种语言(groovy, java, kotlin)的一种构建工具而已。只要我们大概掌握了基本的用法和他的内部原理，日常工作中就会知道自己网上搜到的命令是什么意思啦。skr~</p>
<h2 id="小试牛刀-android中的gradle"><a href="#小试牛刀-android中的gradle" class="headerlink" title="小试牛刀-android中的gradle"></a>小试牛刀-android中的gradle</h2><p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190829093346.png" alt="">  </p>
<p>咱们先看看日常工作中经常用到的几个gradle文件。可以看到主要有有三个文件：<br>1.build.gradle<br>根文件下放的通常放的是针对整个工程的通用配置，每个module下面的build.gradle文件是针对每个module自身的配置。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version = <span class="string">'1.2.71'</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:3.2.1'</span></span><br><span class="line">        classpath <span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个默认的配置，我们可以看到有buildscript，allprojects，repositories，dependencies几个配置项，这些配置项是干嘛的呢，很多的同学在刚学gradle的时候都是一脸懵逼的。这些其实是gradle的一种特定的语法，我们称之为DSL(domain-specific language)。可以参考<a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener">官网</a>。这里可以看到allprojects代理的是每个project，可以理解成我们的每个module，也就是对我们所写的每个module的配置。buildscript主要配置的是打包相关的东西，比如gradle版本，gradle插件版本等，这些都是针对构建工具自己的配置。repositories，dependencies是三方库的仓库和坐标。所以根目录的build.gradle相当于是整体的配置。</p>
<p>而module下的build.gradle主要是android，dependencies等配置项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line"></span><br><span class="line">android&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">dependencies&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可能有些同学会感到奇怪，为啥我们在<a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener">官网</a>没有看到android这个配置项呢？这个主要是因为它并不是gradle的DSL，某种意义上说应该算是android特有的，是通过Android的插件’com.android.application’带进来的配置项。我们如果把第一行删掉，就会发现android{}这个配置项找不到了。</p>
<p>所以，我们可以发现，build.gradle里面的配置项，要么是gradle自带的，要么是各种插件定义的。有不认识的配置项，就去官网查询一下就好了，授人以鱼不如授人以渔嘛。我们后面也会讲解到引进插件的方式和怎么定义插件和配置项。</p>
<p>2.settings.gradle<br>这个文件主要是决定每个module是否参与构建。我们可以这样去理解，settings.gradle相当于是每个module的开关，关上了这个module就不能使用了，别的依赖到它的module也都会出问题。</p>
<p>3.gradle.properties<br>这里主要是增加和修改一些可以在构建过程中直接使用的参数。不只是可以添加自定义参数，还可以修改系统的参数哦~</p>
<p>总结一下，就是说根目录下有一个build.gradle，处理整个工程的配置项，根目录下的settings.gradle配置整个工程中参与构建的module，每个module自己有一个build.gradle，处理自己模块的配置。这就是android构建的一个大概情况。当然，看了这一部分肯定还是不懂怎么去写的，接下来我们走进代码层面。</p>
<h2 id="groovy-学gradle的密钥"><a href="#groovy-学gradle的密钥" class="headerlink" title="groovy-学gradle的密钥"></a>groovy-学gradle的密钥</h2><p>gradle可以使用groovy，kotlin，java等语言进行书写，但是groovy相对来说是目前比较流行的gradle配置方式，下面我们讲解一点groovy基础。不讲太多，够用就行。</p>
<p>1.字符串</p>
<p>groovy的字符串分为两种java.lang.String和groovy.lang.GString。其中单引号和三引号是String类型的。双引号是GString类型的。支持占位插值操作。和kotlin一样，groovy的插值操作也是用<code>${}</code>或者<code>$</code>来标示，<code>${}</code>用于一般替代字串或者表达式，<code>$</code>主要用于A.B的形式中。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> number = <span class="number">1</span> </span><br><span class="line"><span class="keyword">def</span> eagerGString = <span class="string">"value == $&#123;number&#125;"</span></span><br><span class="line"><span class="keyword">def</span> lazyGString = <span class="string">"value == $&#123; -&gt; number &#125;"</span></span><br><span class="line"></span><br><span class="line">println eagerGString</span><br><span class="line">println lazyGString</span><br><span class="line"></span><br><span class="line">number = <span class="number">2</span> </span><br><span class="line">println eagerGString </span><br><span class="line">println lazyGString</span><br></pre></td></tr></table></figure>
<p>2.字符Character</p>
<p>Groovy没有明确的Character。但是可以强行声明。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">'A'</span> </span><br><span class="line"><span class="keyword">assert</span> c1 <span class="keyword">instanceof</span> Character</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> c2 = <span class="string">'B'</span> <span class="keyword">as</span> <span class="keyword">char</span> </span><br><span class="line"><span class="keyword">assert</span> c2 <span class="keyword">instanceof</span> Character</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> c3 = (<span class="keyword">char</span>)<span class="string">'C'</span> </span><br><span class="line"><span class="keyword">assert</span> c3 <span class="keyword">instanceof</span> Character</span><br></pre></td></tr></table></figure>
<p>4.List</p>
<p>Groovy的列表和python的很像。支持动态扩展，支持放置多种数据。使用方法支持def和直接定义。还可以像python那样索引</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List中存储任意类型</span></span><br><span class="line"><span class="keyword">def</span> heterogeneous = [<span class="number">1</span>, <span class="string">"a"</span>, <span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断List默认类型</span></span><br><span class="line"><span class="keyword">def</span> arrayList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">assert</span> arrayList <span class="keyword">instanceof</span> java.util.ArrayList</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用as强转类型</span></span><br><span class="line"><span class="keyword">def</span> linkedList = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="keyword">as</span> LinkedList    </span><br><span class="line"><span class="keyword">assert</span> linkedList <span class="keyword">instanceof</span> java.util.LinkedList</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义指定类型List</span></span><br><span class="line">LinkedList otherLinked = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]          </span><br><span class="line"><span class="keyword">assert</span> otherLinked <span class="keyword">instanceof</span> java.util.LinkedList</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像python一样索引</span></span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">1</span>] == <span class="string">'b'</span></span><br><span class="line"><span class="comment">//负数下标则从右向左index</span></span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">-1</span>] == <span class="string">'d'</span>    </span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">-2</span>] == <span class="string">'c'</span></span><br><span class="line"><span class="comment">//指定item赋值判断</span></span><br><span class="line">letters[<span class="number">2</span>] = <span class="string">'C'</span>             </span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">2</span>] == <span class="string">'C'</span></span><br><span class="line"><span class="comment">//给List追加item</span></span><br><span class="line">letters &lt;&lt; <span class="string">'e'</span>               </span><br><span class="line"><span class="keyword">assert</span> letters[ <span class="number">4</span>] == <span class="string">'e'</span></span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">-1</span>] == <span class="string">'e'</span></span><br><span class="line"><span class="comment">//获取一段List子集</span></span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">1</span>, <span class="number">3</span>] == [<span class="string">'b'</span>, <span class="string">'d'</span>]         </span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">2.</span><span class="number">.4</span>] == [<span class="string">'C'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure>
<p>5.Map</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个Map</span></span><br><span class="line"><span class="keyword">def</span> colors = [<span class="string">red:</span> <span class="string">'#FF0000'</span>, <span class="string">green:</span> <span class="string">'#00FF00'</span>, <span class="string">blue:</span> <span class="string">'#0000FF'</span>]   </span><br><span class="line"><span class="comment">//获取一些指定key的value进行判断操作</span></span><br><span class="line"><span class="keyword">assert</span> colors[<span class="string">'red'</span>] == <span class="string">'#FF0000'</span>    </span><br><span class="line"><span class="keyword">assert</span> colors.green  == <span class="string">'#00FF00'</span></span><br></pre></td></tr></table></figure>
<p>6.运算符</p>
<ul>
<li>**： 次方运算符。</li>
<li>?.：安全占位符。和kotlin一样避免空指针异常。</li>
<li>.@：直接域访问操作符。因为Groovy自动支持属性getter方法，但有时候我们有一个自己写的特殊getter方法，当不想调用这个特殊的getter方法则可以用直接域访问操作符。这点跟kotlin的</li>
<li>.&amp;：方法指针操作符，因为闭包可以被作为一个方法的参数，如果想让一个方法作为另一个方法的参数则可以将一个方法当成一个闭包作为另一个方法的参数。</li>
<li>?:：二目运算符。与kotlin中的类似。</li>
<li><code>*.</code>展开运算符，一个集合使用展开运算符可以得到一个元素为原集合各个元素执行后面指定方法所得值的集合。</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cars = [</span><br><span class="line">    <span class="keyword">new</span> Car(<span class="string">make:</span> <span class="string">'Peugeot'</span>, <span class="string">model:</span> <span class="string">'508'</span>),</span><br><span class="line">   <span class="literal">null</span>,                                              </span><br><span class="line">   <span class="keyword">new</span> Car(<span class="string">make:</span> <span class="string">'Renault'</span>, <span class="string">model:</span> <span class="string">'Clio'</span>)]</span><br><span class="line"><span class="keyword">assert</span> cars*.make == [<span class="string">'Peugeot'</span>, <span class="literal">null</span>, <span class="string">'Renault'</span>]     </span><br><span class="line"><span class="keyword">assert</span> <span class="literal">null</span>*.make == <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>7.闭包<br>groovy里比较重要的是闭包的概念。官方定义是“Groovy中的闭包是一个开放，匿名的代码块，可以接受参数，返回值并分配给变量”。<br>其实闭包跟kotlin的lambda函数很像，都是先定义后执行。但是又有一些细微的区别。接下来我们细讲讲gradle的闭包。</p>
<p>闭包是可以用作方法参数的代码块，Groovy的闭包更象是一个代码块或者方法指针，代码在某处被定义然后在其后的调用处执行。一个闭包实际上就是一个Closure类型的实例。写法和kotlin的lambda函数很像。</p>
<p>我们常见的闭包是这样的<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最基本的闭包</span></span><br><span class="line">&#123; item++ &#125;                                          </span><br><span class="line"><span class="comment">//使用-&gt;将参数与代码分离</span></span><br><span class="line">&#123;item -&gt; item++ &#125;                                       </span><br><span class="line"><span class="comment">//使用隐含参数it</span></span><br><span class="line">&#123; println it &#125;                               </span><br><span class="line"><span class="comment">//使用显示的名为参数</span></span><br><span class="line">&#123; name -&gt; println name &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">a.call()</span><br><span class="line">a()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Groovy的闭包支持最后一个参数为不定长可变长度的参数。</span></span><br><span class="line"><span class="keyword">def</span> multiConcat = &#123; <span class="keyword">int</span> n, String... args -&gt;                </span><br><span class="line">    args.join(<span class="string">''</span>)*n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大家要注意，如果我们单纯的只是写成 a = { item++ }, 这只是定义了一个闭包，是不能运行的。必须调用a.call()才能运行出来。所以大家可以理解了，闭包就是一段代码块而已。当我们有需要的时候，可以去运行它，这么一想是不是和lambda函数很像？</p>
<p>如果你看了<a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener">官网</a>，你会发现有一些这样的说法，</p>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190830093028.png" alt=""></p>
<p>什么叫做delegate？这里涉及到闭包内部的三种对象。</p>
<ul>
<li>this 对应于定义闭包的那个类，如果在内部类中定义，指向的是内部类</li>
<li>owenr 对应于定义闭包的那个类或者闭包，如果在闭包中定义，对应闭包，否则同this一致</li>
<li>delegate 默认是和owner一致，或者自定义delegate指向</li>
</ul>
<p>this和owner都比较好理解。我们可以用闭包的getxxx方法获取<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> thisObject = closure.getThisObject()</span><br><span class="line"><span class="keyword">def</span> ownerObject = closure.getOwner()</span><br><span class="line"><span class="keyword">def</span> delegate = closure.getDelegate()</span><br></pre></td></tr></table></figure></p>
<p>重头戏还是delegate这个对象。闭包可以设置delegate对象，<strong>设置delegate的意义就是将闭包和一个具体的对象关联起来</strong>。<br>我们先来看个例子，这里以自定义android闭包为例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 25</span><br><span class="line">    buildToolsVersion &quot;25.0.2&quot;</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion 15</span><br><span class="line">        targetSdkVersion 25</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个闭包对应的实体类是两个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"># Android.groovy</span><br><span class="line">class Android &#123;</span><br><span class="line">    private int mCompileSdkVersion</span><br><span class="line">    private String mBuildToolsVersion</span><br><span class="line">    private ProductFlavor mProductFlavor</span><br><span class="line"></span><br><span class="line">    Android() &#123;</span><br><span class="line">        this.mProductFlavor = new ProductFlavor()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void compileSdkVersion(int compileSdkVersion) &#123;</span><br><span class="line">        this.mCompileSdkVersion = compileSdkVersion</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void buildToolsVersion(String buildToolsVersion) &#123;</span><br><span class="line">        this.mBuildToolsVersion = buildToolsVersion</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void defaultConfig(Closure closure) &#123;</span><br><span class="line">        closure.setDelegate(mProductFlavor)</span><br><span class="line">        closure.setResolveStrategy(Closure.DELEGATE_FIRST)</span><br><span class="line">        closure.call()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">     String toString() &#123;</span><br><span class="line">        return &quot;Android&#123;&quot; +</span><br><span class="line">                &quot;mCompileSdkVersion=&quot; + mCompileSdkVersion +</span><br><span class="line">                &quot;, mBuildToolsVersion=&apos;&quot; + mBuildToolsVersion + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, mProductFlavor=&quot; + mProductFlavor +</span><br><span class="line">                &apos;&#125;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># ProductFlavor.groovy</span><br><span class="line">class ProductFlavor &#123;</span><br><span class="line">    private int mVersionCode</span><br><span class="line">    private String mVersionName</span><br><span class="line">    private int mMinSdkVersion</span><br><span class="line">    private int mTargetSdkVersion</span><br><span class="line"></span><br><span class="line">    def versionCode(int versionCode) &#123;</span><br><span class="line">        mVersionCode = versionCode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    def versionName(String versionName) &#123;</span><br><span class="line">        mVersionName = versionName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    def minSdkVersion(int minSdkVersion) &#123;</span><br><span class="line">        mMinSdkVersion = minSdkVersion</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def targetSdkVersion(int targetSdkVersion) &#123;</span><br><span class="line">        mTargetSdkVersion = targetSdkVersion</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    String toString() &#123;</span><br><span class="line">        return &quot;ProductFlavor&#123;&quot; +</span><br><span class="line">                &quot;mVersionCode=&quot; + mVersionCode +</span><br><span class="line">                &quot;, mVersionName=&apos;&quot; + mVersionName + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, mMinSdkVersion=&quot; + mMinSdkVersion +</span><br><span class="line">                &quot;, mTargetSdkVersion=&quot; + mTargetSdkVersion +</span><br><span class="line">                &apos;&#125;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后定义的时候就写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//闭包定义</span><br><span class="line">def android = &#123;</span><br><span class="line">        compileSdkVersion 25</span><br><span class="line">        buildToolsVersion &quot;25.0.2&quot;</span><br><span class="line">        defaultConfig &#123;</span><br><span class="line">            minSdkVersion 15</span><br><span class="line">            targetSdkVersion 25</span><br><span class="line">            versionCode 1</span><br><span class="line">            versionName &quot;1.0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">Android bean = new Android()</span><br><span class="line">android.delegate = bean</span><br><span class="line">android.call()</span><br><span class="line">println bean.toString()</span><br><span class="line"></span><br><span class="line">//打印结果</span><br><span class="line">Android&#123;mCompileSdkVersion=25, mBuildToolsVersion=&apos;25.0.2&apos;, mProductFlavor=ProductFlavor&#123;mVersionCode=1, mVersionName=&apos;1.0&apos;, mMinSdkVersion=15, mTargetSdkVersion=25&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就能将闭包中声明的值，赋给两个对象Android和ProductFlavor来处理了。</p>
<p>上面官网的图里，说ScriptHandler被设置成buildscript的delegate。意思就是buildscript定义的参数被ScriptHandler拿来使用了。大家有兴趣的可以去看看ScriptHandler的源码~</p>
<h2 id="Project与Task-gradle构建体系"><a href="#Project与Task-gradle构建体系" class="headerlink" title="Project与Task-gradle构建体系"></a>Project与Task-gradle构建体系</h2><p>上面我们讲完了基本的用法，大家可能懂gradle的配置和写法了。但是可能还是不懂gradle的构建体系到底是怎么样的。这里我们就要深入进gradle的构建体系Project和Task了。下面的东西看着就要动动脑筋了。</p>
<p>1.Task<br>Task是gradle脚本中的最小可执行单元。类图如下：<br><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/006tNc79ly1g2ynzenpu3j30ji0cijsn.jpg" alt=""></p>
<p>值得注意的是因为Gradle构建脚本默认的名字是build.gradle，当在shell中执行gradle命令时，Gradle会去当前目录下寻找名字是build.gradle的文件。<strong>所以只有定义在build.gradle中的Task才是有效的。</strong></p>
<p>可以通过三种方式来声明task。我们可以根据自己的项目需要去定义Task。比如自定义task接管gradle的编译过程<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">task myTask2 &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">"doLast in task2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用 Project.task(String name) 方法来创建</span></span><br><span class="line">project.task(<span class="string">"myTask3"</span>).doLast &#123;</span><br><span class="line">    println <span class="string">"doLast in task3"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用 TaskContainer.create(String name) 方法来创建</span></span><br><span class="line">project.tasks.create(<span class="string">"myTask4"</span>).doLast &#123;</span><br><span class="line">    println <span class="string">"doLast in task4"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TaskContianer 是用来管理所有的 Task 实例集合的，可以通过 Project.getTasks() 来获取 TaskContainer 实例。<br>常见接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">findByPath(path: String): Task</span><br><span class="line">getByPath(path: String): Task</span><br><span class="line">getByName(name: String): Task</span><br><span class="line">withType(type: Class): TaskCollection</span><br><span class="line">matching(condition: Closure): TaskCollection</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建task</span></span><br><span class="line">create(name: String): Task</span><br><span class="line">create(name: String, configure: Closure): Task </span><br><span class="line">create(name: String, type: Class): Task</span><br><span class="line">create(options: Map&lt;String, ?&gt;): Task</span><br><span class="line">create(options: Map&lt;String, ?&gt;, configure: Closure): Task</span><br><span class="line"></span><br><span class="line"><span class="comment">//当task被加入到TaskContainer时的监听</span></span><br><span class="line">whenTaskAdded(action: Closure)</span><br></pre></td></tr></table></figure></p>
<p>Gradle支持增量编译。了解过编译profile文件的朋友都知道，里面有大量的task都是<code>up-to-date</code>。那么这种up-to-date是什么意思呢。<code>Gradle的Task会把每次运行的结果缓存下来，当下次运行时，会检查一个task的输入输出有没有变更。如果没有变更就是up-to-date，跳过编译。</code></p>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/006tNc79ly1g2zg1osecqj30rs0dtwfo.jpg" alt=""></p>
<p>2.Project<br>先从Project对象讲起，Project是与Gradle交互的主接口。android开发中最为我们所熟悉的就是build.gradle文件，这个文件与Project是一对一的关系，build.gradle文件是project对象的委托，脚本中的配置都是对应着Project的Api。Gradle构建进程启动的时候会根据build.gradle去实例化Project类。也就是说，构建的时候，每个build.gradle文件会生成一个Project对象，这个对象负责当前module的构建。</p>
<p>Project本质上是包含多个Task的容器，所有的Task存在TaskContainer中。我们从名字可以看出<br><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/006tNc79ly1g2ynlq52cbj30gb0xxjv3.jpg" alt=""></p>
<p>可以看到dependencies, configuration, allprojects, subprojects, beforeEvaluate, afterEvaluate这些都是我们常见的配置项，在build.gradle文件中接收一个闭包Closure。</p>
<p>好了，现在我们已经聊了build.gradle了，但是大家都知道，我们项目中还有一个settings.gradle呢，这个是拿来干嘛的呢？这就要说到Project的<code>Lifecycle</code>了，也就是Gradle构建Project的步骤，看官网原文：</p>
<ul>
<li>Create a Settings instance for the build.</li>
<li>Evaluate the settings.gradle script, if present, against the Settings object to configure it.</li>
<li>Use the configured Settings object to create the hierarchy of Project instances.</li>
<li>Finally, evaluate each Project by executing its build.gradle file, if present, against the project. The projects are evaluated in breadth-wise order(宽度搜索), such that a project is evaluated before its child projects. This order can be overridden by calling <code>Project.evaluationDependsOnChildren()</code> or by adding an explicit evaluation dependency using <code>Project.evaluationDependsOn(java.lang.String)</code>.</li>
</ul>
<p>也就是说，Project对象依赖Settings对象的构建。我们常在settings.gradle文件中配置需要引入的module，就是这个原因。</p>
<p>3.Property<br>看完了build.gradle和settings.gradle，接下来我们讲讲gradle.properties。这个文件存放的键值对形式的属性，这些属性能被项目中的gradle脚本使用ext.xxx所访问。</p>
<p>我们也可以使用Properties类来动态创建属性文件。如：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> defaultProps = <span class="keyword">new</span> Properties()</span><br><span class="line">defaultProps.setProperty(<span class="string">"debuggable"</span>, <span class="string">'true'</span>)</span><br><span class="line">defaultProps.setProperty(<span class="string">"groupId"</span>, GROUP)</span><br></pre></td></tr></table></figure></p>
<p>并且属性可以继承，在一个项目中定义的属性可以自动被子项目继承。所以在哪个子项目都可以使用project.ext.xxx访问。不同子项目间采用通用的配置插件来配置<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">from:</span> rootProject.file(<span class="string">'library.gradle'</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的学习，大家应该已经了解了gradle的基本配置，写法和比较浅显的内部原理了。因为篇幅原因，深入的内容我们放在下一篇。敬请期待《一篇文章深入gradle》</p>
<p>我是Android笨鸟之旅，一个陪着你慢慢变强的公众号。</p>
<p>参考：<br><a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener">官网</a><br><a href="https://www.jianshu.com/p/6dc2074480b8" target="_blank" rel="noopener">[Android Gradle] 搞定Groovy闭包这一篇就够了</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/从0到1完成一个健身App/路由框架之路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/15/从0到1完成一个健身App/路由框架之路/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-15T09:28:29+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="CrazyRouter"><a href="#CrazyRouter" class="headerlink" title="CrazyRouter"></a>CrazyRouter</h3><p>这个路由框架要达到的功能：<br>第一阶段：<br>1.单module的路由收集和分发能力，支持多个地址路由到一个页面<br>2.支持注入Bundle、Uri的参数并转换格式  3.15-3.17</p>
<p>3.支持跨module路由收集  3.18 - 3.19</p>
<p>4.支持打开Service和Broadcast</p>
<p>调研两到三个路由库，看懂他们的原理，来确定我这个路由库的技术选型。<br>ActivityRouter</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/插件化学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/21/插件化学习笔记/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-21T23:07:36+08:00">
                2019-01-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h2><h3 id="简单的插件化"><a href="#简单的插件化" class="headerlink" title="简单的插件化"></a>简单的插件化</h3><p>代理方式分为静态代理和动态代理。静态代理就是使用代理模式，建造一些proxy对象来代替原对象处理相关的操作。动态代理是根据需要动态的生成，如java中的动态代理技术。</p>
<p>假设我们要启动一个没有在AndroidManifest中声明的Activity，我们没有办法去hook住AMN的操作。只能在启动前和即将启动Activity的时候做文章。基本思路是：</p>
<ul>
<li>在第一步：发送要启动的Activity之前，先把这个Activity替换为一个在AndroidManifest中声明过的StubActivity。<strong>通过AMN.getDefault进行hook，可以同时适用于Activity和Context的startActivity。</strong>在替换以后，要把原来的Activity信息存放在Bundle中。但是这样为啥第二次启动的时候不会被check到？</li>
<li>在第五步：AMS通知App启动StubActivity时，不用去启动StubActivity，而是把StubActivity中存放的原来的Activity给取出来打开。<strong>在这里，我们可以对H类的mCallback字段进行Hook，或者是对ActivityTrhead的mInstrumentation字段进行Hook。这里选择前者</strong>。这样，H类调用handleMessage去处理startActivity的方法的时候，就会被改成真实的Activity地址。</li>
</ul>
<h3 id="插件化基础知识"><a href="#插件化基础知识" class="headerlink" title="插件化基础知识"></a>插件化基础知识</h3><p>加载一个dex：<br>1.可以在MainActivity或者Application的attachBaseContext中进行初始化，这里是早到极致，比onCreate更早。<br>2.通过<strong>面向接口或者抽象编程</strong>，可以避免在项目中需要用到插件中的类的时候只能进行反射处理的问题。<br>3.Android Studio中有六种依赖，后期Compile被改成implement和api：</p>
<ul>
<li>Compile：compile是对所有的build type以及favlors都会参与编译并且打包到最终的apk文件中。</li>
<li>Provided：Provided是对所有的build type以及favlors只在编译时使用，类似eclipse中的external-libs,只参与编译，不打包到最终apk。</li>
<li>APK：只会打包到apk文件中，而不参与编译，所以不能再代码中直接调用jar中的类或方法，否则在编译时会报错</li>
<li>Test compile：仅仅是针对单元测试代码的编译编译以及最终打包测试apk时有效，而对正常的debug或者release apk包不起作用</li>
<li>Debug compile：Debug compile 仅仅针对debug模式的编译和最终的debug apk打包。</li>
<li>Release compile：仅仅针对Release 模式的编译和最终的Release apk打包。</li>
</ul>
<p>典型的Binder模式,有利于后面的理解： 1、客户端通过某种方式得到服务器端的代理对象。从客户端角度看来代理对象和他的本地对象没有什么差别。它可以像其他本地对象一样调用其方法，访问其变量。 2、客户端通过调用服务器代理对象的方法向服务器端发送请求。 3、代理对象把用户请求通过Android内核（Linux内核）的Binder驱动发送到服务器进程。 4、服务器进程处理用户请求，并通过Android内核（Linux内核）的Binder驱动返回处理结果给客户端的服务器代理对象。 5、客户端收到服务器端的返回结果。</p>
<p>4.想要实现插件化，主要是解决下面三个问题：<br>插件中代码的加载和与主工程的互相调用<br>插件中资源的加载和与主工程的互相访问<br>四大组件生命周期的管理</p>
<h3 id="资源初探"><a href="#资源初探" class="headerlink" title="资源初探"></a>资源初探</h3><p>Resources类中的众多访问资源的方法，比如getColor，getText等方法，都是间接调用AssetManager的方法。AssetManager是最终的调用入口。AssetManager有一个addAssetPath方法，在App启动的时候，会当前Apk的路径传进去，这样就可以访问apk的资源了。所以我们可以通过反射的方式，把插件apk的路径传入这个方法，那么app的资源就都在一个资源池中了。</p>
<p>当我们使用R中的id去调用资源时，是使用Apk打包时候<code>aapt</code>的resources.arsc哈希表文件来获取id和资源的对应关系。</p>
<p><strong>所以当我们想要加载自己的dex中的资源时，需要自己生成一个AssetManager，基于这个AssetManager生成Resources，Theme，和Assets对象，并复写Activity的getAssets，getResources，getTheme方法</strong></p>
<p>资源通过<code>aapt</code>打包，所以我们可以在aapt打包生成resources.arsc之后，对resources.arsc进行修改，或者直接修改aapt。</p>
<h3 id="最简单的插件化解决方案"><a href="#最简单的插件化解决方案" class="headerlink" title="最简单的插件化解决方案"></a>最简单的插件化解决方案</h3><p>最简单的方案有：</p>
<ul>
<li>合并所有插件的dex，来解决插件的类的加载问题</li>
<li>预习在宿主的AndroidManifest中声明插件中的四大组件。</li>
<li>把插件中的资源也合并到宿主的资源中</li>
</ul>
<p>以上就是说通过把ClassLoader中的pathList中的dexElements替换为我们原有的和新的插件的dex的list。</p>
<p>缺点是不够灵活，因为无法预声明插件中的四大组件。</p>
<h3 id="Activity的插件化解决方案"><a href="#Activity的插件化解决方案" class="headerlink" title="Activity的插件化解决方案"></a>Activity的插件化解决方案</h3><p>加载插件中类的方案有三：</p>
<ul>
<li>基于动态替换：把插件apk对应的LoadedApk对象，直接放入缓存中，然后把LoadedApk对象的ClassLoader改为插件的ClassLoader。非常麻烦。</li>
<li>合并多个dex。也就是把插件的dex放在ClassLoader的dexList的最前面</li>
<li>修改App原生的ClassLoader</li>
</ul>
<p>Activity可以使用多个Activity来占位处理，如果有LaunchMode的问题，还需要为占位的Activity预定义LaunchMode</p>
<h3 id="Service插件化解决方案"><a href="#Service插件化解决方案" class="headerlink" title="Service插件化解决方案"></a>Service插件化解决方案</h3><p>Service也需要占位。但是不像Activity。Service只能一对一占位。也就是说一个StubService只能对应一个插件中的Service。</p>
<h3 id="ContentProvider插件化"><a href="#ContentProvider插件化" class="headerlink" title="ContentProvider插件化"></a>ContentProvider插件化</h3><p>ContentProvider在加载插件时安装插件Provider</p>
<p>方案：</p>
<ul>
<li>把宿主App和插件App的dex合并到一起</li>
<li>读取插件中的ContentProvider信息，借助PackageParser的parsePackage方法</li>
</ul>
<h3 id="Boradcast插件化"><a href="#Boradcast插件化" class="headerlink" title="Boradcast插件化"></a>Boradcast插件化</h3><p>静态广播以动态广播方式注册。</p>
<h3 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h3><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>ClassLoader:<br>PathClassLoader vs DexClassLoader区别是DexClassLoader可以加载任何路径的apk/dex/jar<br>PathClassLoader只能加载/data/app中的apk，也就是已经安装到手机中的apk。这个也是PathClassLoader作为默认的类加载器的原因，因为一般程序都是安装了，在打开，这时候PathClassLoader就去加载指定的apk(解压成dex，然后在优化成odex)就可以了。</p>
<p>类加载包括了包括加载、验证、准备、解析和初始化五个阶段；对于开发者来说，可控性最强的是加载阶段；加载阶段主要完成三件事：</p>
<ul>
<li>根据一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为JVM方法区中的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/04/C++自学笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/C++自学笔记/" itemprop="url">C++自学笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-04T09:09:44+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-自学笔记"><a href="#C-自学笔记" class="headerlink" title="C++自学笔记"></a>C++自学笔记</h2><h3 id="一-基础"><a href="#一-基础" class="headerlink" title="一. 基础"></a>一. 基础</h3><p>1.变量类型：在C的基础上添加了wchar_t。</p>
<p>2.变量声明：变量和函数声明只在编译时有意义，在程序连接时编译器需要实际的变量声明也就是变量定义。并且声明可以多次，但是变量定义只能一次。</p>
<p>extern修饰变量：用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> count ;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">write_extern</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   count = <span class="number">5</span>;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_extern</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Count is "</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static：存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>
<p>3.类型限定符：</p>
<table>
<thead>
<tr>
<th>const</th>
<th><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</th>
</tr>
</thead>
<tbody>
<tr>
<td>volatile</td>
<td>修饰符 <strong>volatile</strong> 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</td>
</tr>
<tr>
<td>restrict</td>
<td>由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td>
</tr>
</tbody>
</table>
<p>4.函数</p>
<p>默认函数：您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。<strong>注意：这里的默认参数必须放在普通参数之后</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b=<span class="number">20</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  result = a + b;</span><br><span class="line">  <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的三种传值方式：</p>
<ul>
<li>传值调用：把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</li>
<li>指针调用把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</li>
<li>引用调用：把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</li>
</ul>
<p>5.字符串</p>
<p>C风格: char a[10] = “hello”;</p>
<p>C++风格: string a = “s d” + “ ds”;</p>
<h3 id="二-指针与数据结构"><a href="#二-指针与数据结构" class="headerlink" title="二. 指针与数据结构"></a>二. 指针与数据结构</h3><p>1.指针的声明，赋值和取值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var = <span class="number">20</span>;   <span class="comment">// 实际变量的声明</span></span><br><span class="line">   <span class="keyword">int</span>  *ip;        <span class="comment">// 指针变量的声明</span></span><br><span class="line">   ip = &amp;var;       <span class="comment">// 在指针变量中存储 var 的地址 </span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of var variable: "</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; var &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出在指针变量中存储的地址</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Address stored in ip variable: "</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 访问指针中地址的值</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of *ip variable: "</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; *ip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。</p>
<p>2.在函数参数列表中的两种表示方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span>  <span class="comment">// 引用传值，这里&amp;x表示的是传入的参数是一个值，可以直接使用，或者用&amp;取出这个参数的指针</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_2</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span>  <span class="comment">// 指针传值，这里*x代表传入的参数是一个指针，可以直接使用，或者用*取出这个参数的值</span></span></span><br></pre></td></tr></table></figure>
<p>3.指针可以进行数学比较，毕竟都是指针。</p>
<p>4.指针数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr[MAX]  <span class="comment">// 指针数组</span></span><br><span class="line"><span class="keyword">int</span> (*ptr)[MAX] <span class="comment">// 数组指针</span></span><br></pre></td></tr></table></figure>
<p>5.函数中返回指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">function</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>结构变量用.来引出结构中的成员，结构变量指针用-&gt;来引出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">( struct Books *book )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Books Book1;        <span class="comment">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class="line">   Books Book2;        <span class="comment">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Book1 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">"C++ 教程"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">"Runoob"</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">"编程语言"</span>);</span><br><span class="line">   Book1.book_id = <span class="number">12345</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Book2 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">"CSS 教程"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">"Runoob"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">"前端技术"</span>);</span><br><span class="line">   Book2.book_id = <span class="number">12346</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 通过传 Book1 的地址来输出 Book1 信息</span></span><br><span class="line">   printBook( &amp;Book1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 通过传 Book2 的地址来输出 Book2 信息</span></span><br><span class="line">   printBook( &amp;Book2 );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该函数以结构指针作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">( struct Books *book )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"书标题  : "</span> &lt;&lt; book-&gt;title &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"书作者 : "</span> &lt;&lt; book-&gt;author &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"书类目 : "</span> &lt;&lt; book-&gt;subject &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"书 ID : "</span> &lt;&lt; book-&gt;book_id &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三-类和对象"><a href="#三-类和对象" class="headerlink" title="三. 类和对象"></a>三. 类和对象</h3><p>1.继承：C++类定义及使用与Java十分相似，但是引入了继承方式的区别, 规则是：</p>
<blockquote>
<p><strong>public 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</p>
<p><strong>protected 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</p>
<p><strong>private 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</p>
</blockquote>
<p>看个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  A()&#123;</span><br><span class="line">    a1 = <span class="number">1</span>;</span><br><span class="line">    a2 = <span class="number">2</span>;</span><br><span class="line">    a3 = <span class="number">3</span>;</span><br><span class="line">    a = <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//正确</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a1 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//正确</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a2 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//正确</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a3 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//正确</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> a2;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">protected</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  B(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    A();</span><br><span class="line">    a = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//正确，public成员。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a1 &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a2 &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a3 &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//错误，基类的private成员不能被派生类访问。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; b.a &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//正确。public成员</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; b.a1 &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//错误，protected成员不能在类外访问。</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; b.a2 &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//错误，protected成员不能在类外访问。</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; b.a3 &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//错误，private成员不能在类外访问。</span></span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类中变量和函数声明也要使用这三个修饰符。并且默认是private。</p>
<p>2.C++同时引入了析构函数，用于在删除对象的时候运行。C++类会自动控制类的空间的申请和释放。所以析构函数就是在这个时候调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Line::Line(<span class="keyword">double</span> len);</span><br><span class="line">~Line:Line();</span><br></pre></td></tr></table></figure>
<p>3.拷贝构造函数</p>
<p><strong>拷贝构造函数</strong>是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p>
<ul>
<li>通过使用另一个同类型的对象来初始化新创建的对象。</li>
<li>复制对象把它作为参数传递给函数。</li>
<li>复制对象，并从函数返回这个对象。</li>
</ul>
<p>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classname (<span class="keyword">const</span> classname &amp;obj) &#123;    <span class="comment">// 构造函数的主体 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如接下来的例子给出了三者组合的使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 为指针分配内存</span></span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *ptr = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Line::Line(<span class="keyword">const</span> Line &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数并为指针 ptr 分配内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *ptr = *obj.ptr; <span class="comment">// 拷贝值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Line::~Line(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"释放内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.指向类的指针需要使用成员访问运算符-&gt;，就像指向结构的指针一样使用。</p>
<p>5.类的静态成员数据：</p>
<p>与Java不同的地方是不能把静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 <strong>::</strong> 来重新声明静态变量从而对它进行初始化，函数也是如此：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> objectCount;</span><br><span class="line">      <span class="comment">// 构造函数定义</span></span><br><span class="line">      Box(<span class="keyword">double</span> l=<span class="number">2.0</span>, <span class="keyword">double</span> b=<span class="number">2.0</span>, <span class="keyword">double</span> h=<span class="number">2.0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt;<span class="string">"Constructor called."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">         length = l;</span><br><span class="line">         breadth = b;</span><br><span class="line">         height = h;</span><br><span class="line">         <span class="comment">// 每次创建对象时增加 1</span></span><br><span class="line">         objectCount++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">Volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> objectCount;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;     <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;    <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;     <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始化类 Box 的静态成员</span></span><br><span class="line"><span class="keyword">int</span> Box::objectCount = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 在创建对象之前输出对象的总数</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Inital Stage Count: "</span> &lt;&lt; Box::getCount() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="function">Box <span class="title">Box1</span><span class="params">(<span class="number">3.3</span>, <span class="number">1.2</span>, <span class="number">1.5</span>)</span></span>;    <span class="comment">// 声明 box1</span></span><br><span class="line">   <span class="function">Box <span class="title">Box2</span><span class="params">(<span class="number">8.5</span>, <span class="number">6.0</span>, <span class="number">2.0</span>)</span></span>;    <span class="comment">// 声明 box2</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 在创建对象之后输出对象的总数</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Final Stage Count: "</span> &lt;&lt; Box::getCount() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.<strong>运算符重载</strong></p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>
<p>7.<strong>虚函数</strong></p>
<p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。也就是说，虚函数的调用不是在编译时刻确定的，而是在运行时刻确定的</p>
<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>
<p>虚函数有点类似于Java中的可以重写的函数。Java之中可以重写的函数都是运行时候确定的，</p>
<p>如果不想给一个虚函数给出实现，就定为纯需函数。纯虚函数有点像接口的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getVolume</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>8.接口和抽象类</p>
<p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的。</p>
<h2 id="四-高级"><a href="#四-高级" class="headerlink" title="四.高级"></a>四.高级</h2><h3 id="1-文件操作"><a href="#1-文件操作" class="headerlink" title="1.文件操作"></a>1.文件操作</h3><p>文件操作头文件</p>
<ul>
<li>ofstream：输出文件流</li>
<li>ifstream：输入文件流</li>
<li>fstream：文件流，拥有输入输出的功能</li>
</ul>
<p>2.在从文件读取信息或者向文件写入信息之前，必须先打开文件。<strong>ofstream</strong> 和 <strong>fstream</strong> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <strong>ifstream</strong> 对象。</p>
<p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里的openmode指明了打开的模式</p>
<table>
<thead>
<tr>
<th>模式标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ios::app</td>
<td>追加模式。所有写入都追加到文件末尾。</td>
</tr>
<tr>
<td>ios::ate</td>
<td>文件打开后定位到文件末尾。</td>
</tr>
<tr>
<td>ios::in</td>
<td>打开文件用于读取。</td>
</tr>
<tr>
<td>ios::out</td>
<td>打开文件用于写入。</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td>
</tr>
</tbody>
</table>
<p>打开以后使用 &gt;&gt; 和 &lt;&lt; 进行数据的写入与读出。与cout cin类似。</p>
<h3 id="2-C-动态内存"><a href="#2-C-动态内存" class="headerlink" title="2. C++动态内存"></a>2. C++动态内存</h3><p><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</p>
<p><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</p>
<p>通常使用new和delete运算符来申请和删除内存。</p>
<p>如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">double</span>* pvalue  = <span class="literal">NULL</span>; <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">   pvalue  = <span class="keyword">new</span> <span class="keyword">double</span>;   <span class="comment">// 为变量请求内存</span></span><br><span class="line">   *pvalue = <span class="number">29494.99</span>;     <span class="comment">// 在分配的地址存储值</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of pvalue : "</span> &lt;&lt; *pvalue &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">delete</span> pvalue;         <span class="comment">// 释放内存</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-模板"><a href="#3-模板" class="headerlink" title="3.模板"></a>3.模板</h3><p>C++模板和Java模板语法很像。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;left, <span class="keyword">const</span> T &amp;right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (right &lt; left)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   <span class="built_in">vector</span>&lt;T&gt; elems; <span class="comment">// 元素</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span> &amp;)</span></span>; <span class="comment">// 入栈</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;           <span class="comment">// 出栈</span></span><br><span class="line">   <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">// 返回栈顶元素</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">   </span>&#123; <span class="comment">// 如果为空则返回真。</span></span><br><span class="line">      <span class="keyword">return</span> elems.empty();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-线程"><a href="#4-线程" class="headerlink" title="4.线程"></a>4.线程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS     5</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="keyword">void</span> *threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="comment">// 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取</span></span><br><span class="line">   <span class="keyword">int</span> tid = *((<span class="keyword">int</span>*)threadid);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello Runoob! 线程 ID, "</span> &lt;&lt; tid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">   <span class="keyword">int</span> indexes[NUM_THREADS];<span class="comment">// 用数组来保存i的值</span></span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;      </span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"main() : 创建线程, "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      indexes[i] = i; <span class="comment">//先保存i的值</span></span><br><span class="line">      <span class="comment">// 传入的时候必须强制转换为void* 类型，即无类型指针        </span></span><br><span class="line">      rc = pthread_create(&amp;threads[i], <span class="literal">NULL</span>, </span><br><span class="line">                          PrintHello, (<span class="keyword">void</span> *)&amp;(indexes[i]));</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error:无法创建线程,"</span> &lt;&lt; rc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/也谈谈我的2018/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/也谈谈我的2018/" itemprop="url">也谈谈我的2018</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-02T10:15:00+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/年度总结/" itemprop="url" rel="index">
                    <span itemprop="name">年度总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="也谈谈我的2018"><a href="#也谈谈我的2018" class="headerlink" title="也谈谈我的2018"></a>也谈谈我的2018</h2><p>年轻的时候喜欢写一些文章，喜欢铺垫一些比较煽情的气氛，喜欢总结一些看似很有道理的经验。越到年纪大了，越觉得生活就是很平平淡淡的事。尤其是进入社会以来，除去工作以外生活所给的反馈越来越少。更让我加深了这种感慨。有时候就容易感叹：生活真是索然无趣啊。</p>
<p>于是就想着求变。想着2018年没有做好的事情，2019年要用更大的激情和努力来完成，哪怕并没有达到自己年初的预期，想来也总算有个盼头。就像小的时候盼着过年，读书的时候盼着高考一样，进入社会了总不能盼着早点退休吧。咳咳。</p>
<p>我以为回顾起我的2018，会像某些朋友一样：这是xxxx的一年，也是xxxx的一年。但是对我来说，2018年过的有点太快了。快到我没有好好体会就结束了。毕业论文，答辩，适应工作。我现在只能想起这几个词。毕业论文选择了做一点偏研究性的工作，想体会一下真正的科研人员们的快乐，提升一下自己的研究能力，然后那段时间就是疯狂的看论文，想idea。结果终究还是有点准备不足，就算花了很多的时间还是没有达到比较好的效果。但是也推翻了自己对自己的一种固有观念：不喜欢搞科研。人生还是有无限可能的。不想自己给自己设限。从此以后，应该会去追求更多的可能性和多样性吧。</p>
<p>临到毕业的时候想着出国去做做义工旅行，困于囊中羞涩打消了计划。其实内心里还是很想去的。想去老挝的琅勃拉邦，过一段时间日出而作日落而息的生活。远离手机和电脑，多点对自己人生的思考。这一点其实也是对自己大学的不满。感觉大学期间的自己浑浑噩噩，很多事情都没有做到过自己能力范围内的最好，与自己的预期相差甚远。加权没有进入前十，没有好好利用图书馆，没有去做一件让自己离开大学也会念念不忘的大事。甚至于自己拿来谋生的技能，自己也不算做的很好，学习精力分散，杂而不精。更重要的是，内心变得十分的浮躁，越来越少的思考，经常直接接受不用消化的信息和知识。总想有段时间能进行反思总结，结果没能去成。没去成也就罢了吧。自己慢慢的去改正吧。这半年来也已经慢慢改了不少了。</p>
<p>进入工作以来，自己进入了一个适应期。如何跟同事沟通，如何完成上级分配的任务，如何摆正自己的心态，如何规划自己的未来道路，如何更快更好的提升自己。十分感谢导师和leader对我的帮助。我感觉慢慢适应了自己的工作，也对自己的未来慢慢的有了一些规划和安排。进入头条感觉很幸运，同时也感觉很有挑战。每天都下班很晚，周末还经常加班。大家都是抱着对项目的期待在努力着。对于我来说，必须自己粗心，做事不细致不严谨的毛病，慢慢成为一个踏实靠谱，能独当一面的人。过几天我的试用期就结束了，希望不要被裁掉。哈哈。也希望新的一年，自己能尽快成长，进步的速度大于头发脱落的速度。</p>
<p>这一年里感情方面跟女朋友关系也算磨合的更有默契了。两个人都对对方有了更深的了解，所以对两个人在一起的状态也有了更多的思考。两个人性格都偏温和，平时也没啥吵闹，凡事商量着来。尽量去礼让对方。分手几次后，争吵的更少了，也算是带来了一些益处。</p>
<p>按照我司OKR的评价标准评价自己的2018年，我打个6.5分。各方面都有较高的努力空间。未来可期。</p>
<p>2019年，对于自己的期望是把现在的一些能做的事做到最好。思想上能摒弃一些无益的糟粕，兴趣爱好能有一些拿得出手的成就。事业上成长的足够快，生活上更有规律更健康，感情上更成熟稳定。我也立个okr吧，明年今天复验，完不成的话，就罚自己吃公司健康餐一个月。</p>
<p>2019年 OKR:</p>
<ol>
<li>github上有一两个长久维护的库，能跟着自己的技术成长的那种。阅读至少20个优秀开源库源码</li>
<li>按照自定的计划继续坚持健身。今年的目标是体重达到65kg或体脂率达到13，身材匀称。</li>
<li>学完《吉他自学三月通》，滑板学会ollie和一些中低级动作</li>
<li>更深入的学习MMA。项目空闲后每周周末一次实战。</li>
<li>每月看一本专业无关的闲书。</li>
<li>早睡早起，养成为革命持续奋斗的作息习惯。持续养生，不做地中海！</li>
</ol>
<p>2019，冲鸭！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/30/书海拾贝/自控力/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/30/书海拾贝/自控力/" itemprop="url">自控力</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-30T10:15:00+08:00">
                2018-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/书籍/" itemprop="url" rel="index">
                    <span itemprop="name">书籍</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="自控力"><a href="#自控力" class="headerlink" title="自控力"></a>自控力</h2><p>这一周终于把拖了很久没看的自控力看完了。用一句话来归纳自己的所得，可以总结为：感觉自己学习到了什么，又好像啥都没学到，又好像见识到了什么，但是对自己来说又有好多的争议点。下面我会针对自己的一些摘录，提供一些自己的思考，由于是第一次这样去做，可能还是不够完善。</p>
<h3 id="摘录及有得"><a href="#摘录及有得" class="headerlink" title="摘录及有得"></a>摘录及有得</h3><p>是非判断对自控力的影响：<br>1.当说到孰是孰非时，我们都能毫不费力地作出符合道德标准的选择。我们只想让自己感觉良好，而这就为自己的胡作非为开了绿灯。<br>2.只要我们的思想中存在正反两方，好的行为就总是允许我们做一点坏事<br>3.不要把支持目标实现的行为误认为是目标本身。不是说你做了一件和你目标一致的事情，你就不会再面临危险了。注意观察一下，你是否因为认为某些积极的行为值得称赞，就忘了自己实际的目标是什么。</p>
<blockquote>
<p>当我们把事情分割成正反两方时候，我们就很容易为了一点好处而搭上另外一些代价。或者说是更心安理得的去接收一些对我们自控有害的东西。比如标注了低糖的可乐总是会成功的俘获减肥的我们。减肥期的人本来就不应该喝可乐，低糖成功的降低了我们的注意力。</p>
</blockquote>
<p>关注过程对自控力的影响：<br>1.虽然这个观点不符合我们对“完成目标”的看法，但关注进步确实会让我们离成功越来越远。这不是说进步本身是个问题，问题在于进步给我们带来的感觉。更进一步说，问题是我们不能坚持自己的目标，而会听从自己的感觉。进步可以激励人，甚至可以提高未来的自控力，但前提是，你要把自己的行动当做努力完成目标的证据。<br>2.不要把支持目标实现的行为误认为是目标本身。不是说你做了一件和你目标一致的事情，你就不会再面临危险了。注意观察一下，你是否因为认为某些积极的行为值得称赞，就忘了自己实际的目标是什么。<br>3.虽然这个观点不符合我们对“完成目标”的看法，但关注进步确实会让我们离成功越来越远。这不是说进步本身是个问题，问题在于进步给我们带来的感觉。更进一步说，问题是我们不能坚持自己的目标，而会听从自己的感觉。进步可以激励人，甚至可以提高未来的自控力，但前提是，你要把自己的行动当做努力完成目标的证据。</p>
<blockquote>
<p>当我们要实现某个目标时，如果计划比较长远，可以分解成一步一步的小台阶，关注自己在每个小台阶上得到的进步，这样会让我们更有攀登高峰的决心。但是我们同样要有意识，我们的小进步并不是目标本身，我们依然要以长远为导向</p>
</blockquote>
<p>道德光环带来的影响：<br>1.这种“道德许可”的形式为你对诱惑说“好的”提供了充足的理由。当我们想获得放纵许可的时候，我们会寻找任何一个美德的暗示，为自己放弃抵抗作辩护。<br>2.只要使你放纵的东西和使你觉得品德高尚的东西同时出现，就会产生光环效应。比如，研究人员发现，出于慈善目的购买巧克力的人，会吃更多的巧克力来奖励自己的善行</p>
<blockquote>
<p>给自己带上一层道德光环，就容易放任自己做一些坏事</p>
</blockquote>
<p>多巴胺与奖励系统对自控力的影响：<br>1.我们会发现，在追求幸福的时候，我们可不能相信大脑指引的方向。我们还会发现，神经营销学这个全新领域是如何利用这个原理来操控我们的大脑、为我们制造欲望的，以及我们如何才能抵抗这种欲望。<br>2.奖励系统是怎么迫使我们行动的呢？当大脑发现获得奖励的机会时，它就释放出叫做多巴胺的神经递质。多巴胺会告诉大脑其他的部分它们需要注意什么，怎样才能让贪婪的我们得手<br>3.克努森证明了，多巴胺控制的是行动，而不是快乐。奖励的承诺保证了被试者成功地行动，从而获得奖励。当奖励系统活跃的时候，他们感受到的是期待，而不是快乐。<br>4.现代科技“及时行乐”的特点，加上原始的激励系统，就让我们成了多巴胺的奴隶，从此欲罢不能。我们中的一些人应该还记得那种狂按电话答录机按钮、查收新消息的刺激感。后来，我们又通过调制解调器连上了美国在线，希望电脑会告诉我们：“你收到了新邮件！”好吧，我们现在有了Facebook、Twitter、电子邮件和短信息——这就是精神病专家罗伯特·希斯设计的自我刺激设备的现代版<br>5.<strong>难以预料的，经常变化的奖励比通常的奖励更有吸引力</strong><br>6.奖励的承诺有很大的力量，它会让我们继续追求那些不会带给我们快乐的东西，会让我们消费那些不会带来满足感，只会带来更多痛苦的东西。追求奖励是多巴胺的主要目标，所以，即便你经历的事物和原本承诺的并不相符，它也不会给你释放“停下来”的信号。<br>7.奖励系统也很重要：快感缺乏的人认为生活就是一系列的习惯，他们没有对满足感的期待。他们可以吃东西、购物、社交，甚至有性生活，但不会期待从中获得快乐。当他们不再需要快感的时候，他们就失去了动力。如果你想不出任何一件让你感觉良好的事，你就很难从床上爬起来做事。这种毫无欲望的状态耗尽了希望，也夺走了很多人的生命。</p>
<blockquote>
<p>很多时候我们都是被奖励系统驱使着。比如游戏，冲动的犯罪，当我们每次被奖励系统驱使着的时候，只要质问一下自己：这真的会让我快乐吗？应该就能更好的自控。但是这奖励系统又太过于重要，是一个人追求幸福不能缺少的东西，不然人生就会毫无干劲</p>
</blockquote>
<p>压力对自控力的影响：<br>1.为什么压力会带来欲望呢？因为这是大脑援救任务的一部分。此前，我们看到了压力是如何引发应激反应的。应激反应是身体内部相互协调的一系列变化，让你能在面临危险的时候保护自己。但人脑不仅仅会保护人的生命，它也想维持人的心情。所以，当你感到压力时，你的大脑就会指引着你，让你去做它认为能带给你快乐的事情。<br>2.有效和无效的策略最主要的区别是什么？真正能缓解压力的不是释放多巴胺或依赖奖励的承诺，而是增加大脑中改善情绪的化学物质，<br>3.美国心理学家协会的调查发现，最有效的解压方法包括：锻炼或参加体育活动、祈祷或参加宗教活动、阅读、听音乐、与家人朋友相处、按摩、外出散步、冥想或做瑜伽，以及培养有创意的爱好。<br>4.我们有时候产生强烈的不适感，或者我们并不知道这是为什么。即使我们意识不到这种恐惧，它还是会让我们立即作出回应，对抗自己的无力感。我们会去寻找保护伞，寻找任何能让自己觉得安全、有力量、得到安慰的东西。<br>5.屈服会让你对自己失望，会让你想做一些改善心情的事。那么，最廉价、最快捷的改善心情的方法是什么？往往是做导致你情绪低落的事。</p>
<p>延迟满足感：<br>1.经济学家称之为“延迟折扣”。也就是说，等待奖励的时间越长，奖励对你来说价值越低。很小的延迟就能大幅降低你感知到的价值。<br>2.对那些想延迟快感的人来说，这是个好消息。只要你能创造一点距离，就会让拒绝变得容易起来。比如，一项研究发现，把糖果罐放在桌子的抽屉里，而不是直接放在桌上，会让办公室职员少吃1/3的糖。<br>3.想获得一个冷静明智的头脑，我们就需要在所有诱惑面前安排10分钟的等待时间。如果10分钟后你仍旧想要，你就可以拥有它。</p>
<blockquote>
<p>当我们确实想要打破自己的计划的时候，延迟十分钟思考一下。在制定计划的时候，也要考虑到让自己和诱惑的距离远一点。</p>
</blockquote>
<p>总是期待未来：<br>1.如果我们真的指望未来的自己能这么崇高，我们确实可以相信，未来的自己能做好所有的事。但更典型的情况是，当我们到了未来，理想中“未来的自己”却不见了，最后作决定的还是毫无改变的曾经的自己。即便我们现在已经失去了自控力，我们仍然愚蠢地希望未来的自己不会面临冲突。<br>2.向未来的自己描述一下自己现在将要做什么，有助于你实现长期目标。你对未来的自己有什么希望？你觉得自己会变成什么样？你也可以想象未来的自己回头看现在的自己。未来的自己会因为现在的自己做了什么而表示感激？</p>
<blockquote>
<p>把希望和努力放在现在，而把享受留给明天</p>
</blockquote>
<p>社会对我们的控制力的影响：<br>1.实际在很大程度上，那些我们通常认为受自控力影响的行为，也会受社会控制力的影响。我们愿意相信，我们的决定不会受他人的影响，我们为自己的独立和自由意志感到自豪。<br>2.在考虑如何作出选择时，我们经常想象自己是别人评估的对象。研究发现，这为人们自控提供了强大的精神支持。预想自己实现目标（比如戒烟或献血）后会非常自豪的人，更有可能坚持到底并获得成功，预想自己的行为会受到谴责也很有效。<br>3.为了让自豪感发挥作用，我们必须认为别人都在监视自己，或我们有机会向别人报告自己的成功。市场研究人员发现，人们在公开场合更愿意购买绿色产品，比他们私下网购时买得多。<br>4.当人们试着不去想某件事时，反而会比没有控制自己的思维时想得更多，比自己有意去想的时候还要多。这个效应在人处于紧张、疲劳或烦乱状态时最为严重。韦格纳把这个效应称为“讽刺性反弹”（<br>5.避免讽刺性反弹 怎么才能找到摆脱这种困境的方法呢？韦格纳提出了一种对抗讽刺性反弹的方法。这个方法本身就很有讽刺意味——这个方法就是放弃自控。当人们不再试图控制那些不希望出现的想法和情绪时，它们也就不会再来烦你了。大脑激活研究证实，一旦允许研究对象把压抑的想法表达出来，这个想法就不太容易被激活了，因此进入意识的可能性也变小了。这件事说起来有点矛盾——允许你去想一件事，反而会减少你想起它的可能性。</p>
<blockquote>
<p>这个点也很新颖。但是也确实是这样的。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/30/Java知识深入/你所不知道的Method Handles/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/30/Java知识深入/你所不知道的Method Handles/" itemprop="url">你所不知道的Method Handles</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-30T10:15:00+08:00">
                2018-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Method-Handles"><a href="#Method-Handles" class="headerlink" title="Method Handles"></a>Method Handles</h2><p>Method Hanldes是在Java 7引入的概念。全限定名是java.lang.invoke.MethodHandles。在这篇文章中，我们将学会如何创建，使用MethodHandles及它的原理。</p>
<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>Method Handles的引入是为了与已经存在的java.lang.reflect API相配合。他们分别是为了解决不同的问题而出现的。从性能角度上说，MethodHandle api要比反射快很多因为访问检查在创建的时候就已经完成了，而不是像反射一样等到运行时候才检查。但同时，Method Handles比反射更难用，因为没有列举类中成员，获取属性访问标志之类的机制。<br>另外，MethodHandles可以操作方法，更改方法参数的类型和他们的顺序。而反射则没有这些功能。<br>从以上角度看，反射更通用，但是安全性更差，因为可以在不授权的情况下使用反射对象。而method Handles遵从了分享者的能力。所以method handle是一种更低级的发现，适配和调用方法的方式，唯一的优点就是更快。所以反射更适合主流Java开发者，而method handle更适用于对编译和运行性能有要求的人。</p>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><p>1.要使用method handle，首先需要得到Lookup。这是创造方法，构造函数，属性的method handles的工厂类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public方法的Lookup</span></span><br><span class="line">MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();</span><br><span class="line"><span class="comment">// 所有方法的Lookup</span></span><br><span class="line">MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br></pre></td></tr></table></figure></p>
<p>2.要创建MethodHandle，lookup需要一个定义了它的类型的MethodType对象。这里的类型包括了传入参数的类型，和最后返回的类型，要一一对应。第一个是返回类型，如果没有返回值就是Void.class, 后面是可变的传入参数的类型。</p>
<blockquote>
<p> a MethodType represents the arguments and return type accepted and returned by a method handle or passed and expected by a method handle caller.</p>
</blockquote>
<p>例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数组，返回一个List对象</span></span><br><span class="line">MethodType mt = MethodType.methodType(List.class, Object[].class);</span><br></pre></td></tr></table></figure></p>
<p>3.查找MethodHandle<br>Lookup之所以叫Lookup自然是因为他们有查找MethodHandle的能力。先看看他的方法。<br><img src="http://ovkwd4vse.bkt.clouddn.com/屏幕快照 2018-10-19 上午10.19.20.png" alt="屏幕快照 2018-10-19 上午10.19.20.png"></p>
<p>4.接下来就可以进行查找并调用了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MethodType mt = MethodType.methodType(String.class, <span class="keyword">char</span>.class, <span class="keyword">char</span>.class);</span><br><span class="line">MethodHandle replaceMH = publicLookup.findVirtual(String.class, <span class="string">"replace"</span>, mt);</span><br><span class="line"> </span><br><span class="line">String output = (String) replaceMH.invoke(<span class="string">"jovo"</span>, Character.valueOf(<span class="string">'o'</span>), <span class="string">'a'</span>);</span><br></pre></td></tr></table></figure></p>
<p>5.方法调用细则：<br>有三种方法可以调用方法invoke(), invokeWithArugments()和invokeExact()，当我们使用invoke时，我们必须固定arguments的数目。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invoke使用</span></span><br><span class="line">MethodType mt = MethodType.methodType(String.class, <span class="keyword">char</span>.class, <span class="keyword">char</span>.class);</span><br><span class="line">MethodHandle replaceMH = publicLookup.findVirtual(String.class, <span class="string">"replace"</span>, mt);</span><br><span class="line">String output = (String) replaceMH.invoke(<span class="string">"jovo"</span>, Character.valueOf(<span class="string">'o'</span>), <span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// invokeWithArguments使用</span></span><br><span class="line">MethodType mt = MethodType.methodType(List.class, Object[].class);</span><br><span class="line">MethodHandle asList = publicLookup.findStatic(Arrays.class, <span class="string">"asList"</span>, mt);</span><br><span class="line">List&lt;Integer&gt; list = (List&lt;Integer&gt;) asList.invokeWithArguments(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// invokeExact</span></span><br><span class="line">MethodType mt = MethodType.methodType(<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">MethodHandle sumMH = lookup.findStatic(Integer.class, <span class="string">"sum"</span>, mt);</span><br><span class="line"><span class="keyword">int</span> sum = (<span class="keyword">int</span>) sumMH.invokeExact(<span class="number">1</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure></p>
<p>具体的区别是：</p>
<blockquote>
<p>与invokeExact方法不同，invoke方法允许更加松散的调用方式。它会尝试在调用的时候进行返回值和参数类型的转换工作。这是通过MethodHandle类的asType方法来完成的，asType方法的作用是把当前方法句柄适配到新的MethodType上面，并产生一个新的方法句柄。当方法句柄在调用时的类型与其声明的类型完全一致的时候，调用invoke方法等于调用invokeExact方法；否则，invoke方法会先调用asType方法来尝试适配到调用时的类型。如果适配成功，则可以继续调用。否则会抛出相关的异常。这种灵活的适配机制，使invoke方法成为在绝大多数情况下都应该使用的方法句柄调用方式。</p>
</blockquote>
<p>参考：<br><a href="https://www.baeldung.com/java-method-handles" target="_blank" rel="noopener">https://www.baeldung.com/java-method-handles</a><br><a href="https://www.cnblogs.com/night-wind/p/4405564.html" target="_blank" rel="noopener">https://www.cnblogs.com/night-wind/p/4405564.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/19/从0到1完成一个健身App/从0到1之二：路由框架设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/19/从0到1完成一个健身App/从0到1之二：路由框架设计/" itemprop="url">从零到一完成一个健身App之二：路由框架设计(未完成)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-19T10:15:00+08:00">
                2018-09-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/从零到一健身App/" itemprop="url" rel="index">
                    <span itemprop="name">从零到一健身App</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从零到一完成一个健身App之二：路由框架设计"><a href="#从零到一完成一个健身App之二：路由框架设计" class="headerlink" title="从零到一完成一个健身App之二：路由框架设计"></a>从零到一完成一个健身App之二：路由框架设计</h1><h2 id="1-路由框架的相关背景"><a href="#1-路由框架的相关背景" class="headerlink" title="1.路由框架的相关背景"></a>1.路由框架的相关背景</h2><p>路由框架是组件化大背景下出现的一种成熟方案。</p>
<p>相信有过组件化开发经验的同学都会知道，如果我们想在Module A中打开Module B中的Activity，这时候的Activity是找不到引用的。显式跳转是行不通的。另外，在很多时候我们都需要后台来动态确定我们需要跳转到什么页面。比如常见的分享码等。除此之外，H5页面越来越多，而H5页面是没办法通过startActivity跳到原生页面的。所以在这种情况下需要定义一种更适合组件化的，更灵活的路由方式。</p>
<p>为了找到这种方式，我们经历了以下过程</p>
<ol>
<li>隐式意图Activity跳转：依赖于Manifest文件的修改，并且参数不方便传递。使用了startActivity之后就无法插手任何环节了，就无法在跳转失败的时候降级。</li>
<li>基于事件，广播或EventBus，这种情况下跳转流不容易监控，而且在跳转复杂的情况下接入维护成本较高</li>
<li>调用一个固定的方法：这种情况侵入性太强，所有Activity都要实现，改造起来困难，难于扩展。</li>
</ol>
<p>所以我们需要一个优秀的路由框架，要能够实现：</p>
<ul>
<li>通过与后台一起定义schema，可以达到按后台所需跳转到特定页面的需求，也可以和H5页面统一跳转方式</li>
<li>代码侵入性弱，调用方便。</li>
<li>接入方简单易用。</li>
<li>灵活，能针对特定需求进行特定的处理。比如我们常见的登录判断和权限检查等。</li>
</ul>
<p>具体到实现方面，要能做到：</p>
<ul>
<li>路由注册采用apt注解式自动生成，避免手动管理</li>
<li>参数依赖注入，自动保存，不再需要手动写onSaveInstance、onCreate(SaveInstace)、onNewIntent(Intent)、getQueryParamer等</li>
<li>能动态拦截和动态替换</li>
</ul>
<h2 id="2-现有框架调研"><a href="#2-现有框架调研" class="headerlink" title="2.现有框架调研"></a>2.现有框架调研</h2><p>当前比较知名的路由框架有：阿里的ARouter，美团的WMRouter，ActivityRouter.</p>
<h3 id="2-1-ARouter"><a href="#2-1-ARouter" class="headerlink" title="2.1 ARouter"></a>2.1 ARouter</h3><p>ARouter有多个优势：<br>1.直接解析URL路由，解析参数并赋值到对应目标字段的页面中;<br>2.支持多模块项目;<br>3.支持InstantRun;<br>4.拦截器策略，允许自定义;<br>5.提供IoC容器,控制反转;<br>6.映射关系自动注册;<br>7.灵活的降级策略.</p>
<p>赶紧学习一下这些都是怎么做到的。先看一个示例<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/test/activity2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">ARouter.getInstance().build("/test/activity2")..withString("key1", "value1").navigation();</span><br></pre></td></tr></table></figure></p>
<p>再看看ARouter的架构。<br><img src="http://ovkwd4vse.bkt.clouddn.com/37b723fb660fdfcf7cdc09c194c88a8073d8272d.png" alt="37b723fb660fdfcf7cdc09c194c88a8073d8272d.png"></p>
<p>其中Compiler中三个处理器，分别是：<br>Route Processor：处理路径路由<br>Interceptor Processor：处理拦截器<br>Autowire Processor：进行自动装配</p>
<p>API中Launcher是用户可以调用的api所在的地方<br>Service是将功能和组件封装成的接口，对外开放。等到时候分析源码的时候要注意一下是怎么做到的。<br>Templete是用于SDK编译器生成映射文件时候提供的模板。<br>更下层的ware House: 存储了ARouter在运行期间加载的一些配置文件以及映射关系<br>Thread则是提供了线程池，因为存在多个拦截器的时候以及跳转过程中都是需要异步执行的<br>Class工具则是用于解决不同类型APK的兼容问题的。<br>再下一层就是Logistics Center，从名字上翻译就是物流中心，整个SDK的流转以及内部调用最终都会下沉到这一层, 也按功能模块划分。</p>
<p>一.如何实现解析URL路由，解析参数并赋值到目标字段中？<br>ARouter采用的是APT技术，通过定义的annotation来解析到相应的path。这里会遇到的第一个问题是找到处理注解的时机。运行期处理注解会大量的运用反射。所以要在编译期处理被注解的类。至于如何区分，就在于这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用来指明注解的访问范围</span></span><br><span class="line"><span class="comment">*  1.源码级注解SOURCE，该类型的注解信息会留在.java源码中，</span></span><br><span class="line"><span class="comment">*    源码编译后，注解信息会被丢弃，不会保留在编译好的.class文件中；</span></span><br><span class="line"><span class="comment">*  2.编译时注解CLASS，注解信息会保留在.java源码里和.class文件中，</span></span><br><span class="line"><span class="comment">*    在执行的时候，会被Java虚拟机丢弃不回家再到虚拟机中；</span></span><br><span class="line"><span class="comment">*  3.运行时注解RUNTIME，java源码里，.class文件中和Java虚拟机在运行期也保留注解信息，</span></span><br><span class="line"><span class="comment">*    可通过反射读取</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="comment">//是一个ElementType类型的数组，用来指定注解所使用的对象范围</span></span><br><span class="line"><span class="meta">@Target</span>(value = FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Add &#123;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">ele1</span><span class="params">()</span> <span class="keyword">default</span> 0f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">ele2</span><span class="params">()</span> <span class="keyword">default</span> 0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/17/从0到1完成一个健身App/从0到1之一：开篇词与项目总体架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/从0到1完成一个健身App/从0到1之一：开篇词与项目总体架构/" itemprop="url">从零到一完成一个健身App之一：开篇词和项目概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-17T10:15:00+08:00">
                2018-09-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/从零到一健身App/" itemprop="url" rel="index">
                    <span itemprop="name">从零到一健身App</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从零到一完成一个健身App"><a href="#从零到一完成一个健身App" class="headerlink" title="从零到一完成一个健身App"></a>从零到一完成一个健身App</h1><h2 id="一-开篇词"><a href="#一-开篇词" class="headerlink" title="一.开篇词"></a>一.开篇词</h2><p>我的计划是用一年半到两年的时间完成一个健身App。</p>
<p>1.目的：我是一个喜欢接受新技术的人。但是我又是一个很懒的人，这种懒惰体现在自己对于技术可能很多时候只限于使用的地步，而没有去深挖技术内部原理和实现细节，并且对于App的设计也缺乏一定的思考。现在自己已经在公司工作两个月了，从公司的项目中开阔了眼界。但是苦于没有地方练手。所以想找个App把自己学到的应用上来。目前来看，自己对于Android较为深入的技术都缺乏认知，都是需要强补的。这也是我想从头开始设计一个好的应用的原因。</p>
<p>2.项目现状与预期：这个应用是我为自己这种健身爱好者量身打造的应用，也打算部分参考keep和抖音的设计。之前未毕业前就有开始过这个项目的开发，但是当时因为毕业而搁置了。现在再拿出来看，当时的代码写的非常的傻逼。于是打算推翻重来。预期是：</p>
<ul>
<li>学会使用主流框架，如fresco，Architecture Component，RxJava等。</li>
<li>结合组件化和插件化，热修复等技术</li>
<li>对于一些较为简单的工具，如路由框架，能自行编写</li>
<li>关注性能优化</li>
<li>在项目的一些模块中能接触到深度学习。做一个AI赋能的App</li>
</ul>
<p>3.项目计划：因为现在在公司项目中确实压力比较大，10，10，大小周。目前来看，自己能用在这个项目上的时间是早上的八点半到十点。晚上的十点四十到十一点四十。周末也有时间可以搞一搞。考虑到自己可能需要学习很多的知识，而且自己平时的时间也不一定能放到这个上面来，预计需要一年半到两年的时间里完成这个项目。在这两年里，我会每两周根据自己的项目情况完成一篇博客。因为是自己的项目，代码中不会出现公司的代码，所有的代码都是自己学习后产出的。也不希望有人将我这项目用于商业目的。</p>
<p>4.专栏适合的人群：</p>
<ul>
<li>有一定Android开发经验，处于Android基础和进阶之间的人</li>
<li>想通过一个完整项目接触到当前互联网公司里最火热的技术的人</li>
<li>作为Android开发，想接触到深度学习等在Android中应用的人</li>
<li>适用于想一步一步提升自己各方面Android技术的人</li>
</ul>
<h2 id="二。项目概述"><a href="#二。项目概述" class="headerlink" title="二。项目概述"></a>二。项目概述</h2><p>1.项目将会采用的总体架构：</p>
<ul>
<li><p>MVVM和Architecture Component：相信大家都知道有MVC，MVP，和MVVM三种架构，MVC就不说了，MVP在很长的一段时间里都是主流，但是已经体验过MVVM的我不可能再用MVP了-_- 。常用的MVVM框架有databinding，但是databinding会带来业务代码耦合进xml中的问题，扩展性也差。我决定使用google的Architecture Component。谷爹出品，值得信赖，而且还挺好用的，很多数据问题都得到了解决。</p>
</li>
<li><p>RxJava：Rxjava作为一个成熟的库，事件流和函数式编程的思想深入人心</p>
</li>
<li>okhttp+retrofit：这两个框架是当今大厂的主流网络框架，也是学习网络相关的重要入口，我会在基本使用的基础上去挖掘相关的值得学习和有亮点的地方。</li>
<li>fresco：这也是最强大和性能最好的图片框架了。</li>
<li>插件化+组件化+热修复：这三个是类似的，但是又有一些区别。我倾向于每种技术都自己实现一个框架，其中组件化的路由框架我是一定要写的，代码量并不多。其他的就等到时候再看，如果有时间就自己写一个。</li>
<li>AOP技术：主要是用来进行日志和自动埋点等。目前对这块不是特别熟悉，等到时候再考虑吧。</li>
<li>JNA：由于之前没怎么接触过JNI技术，对相关的技术都不是很了解。所以在这个项目中想加入一些特效相关的处理，这也是我的兴趣所在。不可避免的要使用到native方法。因此打算使用JNA这个库</li>
<li>深度学习框架：目前暂定ncnn，腾讯优图出品的开源深度学习框架，看评测是要强于目前所有已知开源框架。</li>
<li>数据库：因为Realm的一些坑，数据库框架打算采用GreenDao。</li>
<li>下载库：打算自己实现一个比较有意思的库。目前公司的项目有，自己可以吸收其精华，去掉自己不需要的部分。</li>
</ul>
<p>再次声明：本项目中不会有公司项目的源码，都是自己完成。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">oubindo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">oubindo</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
