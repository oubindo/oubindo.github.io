## 插件化
### 简单的插件化
代理方式分为静态代理和动态代理。静态代理就是使用代理模式，建造一些proxy对象来代替原对象处理相关的操作。动态代理是根据需要动态的生成，如java中的动态代理技术。

假设我们要启动一个没有在AndroidManifest中声明的Activity，我们没有办法去hook住AMN的操作。只能在启动前和即将启动Activity的时候做文章。基本思路是：
- 在第一步：发送要启动的Activity之前，先把这个Activity替换为一个在AndroidManifest中声明过的StubActivity。**通过AMN.getDefault进行hook，可以同时适用于Activity和Context的startActivity。**在替换以后，要把原来的Activity信息存放在Bundle中。但是这样为啥第二次启动的时候不会被check到？
- 在第五步：AMS通知App启动StubActivity时，不用去启动StubActivity，而是把StubActivity中存放的原来的Activity给取出来打开。**在这里，我们可以对H类的mCallback字段进行Hook，或者是对ActivityTrhead的mInstrumentation字段进行Hook。这里选择前者**。这样，H类调用handleMessage去处理startActivity的方法的时候，就会被改成真实的Activity地址。


### 插件化基础知识
加载一个dex：
1.可以在MainActivity或者Application的attachBaseContext中进行初始化，这里是早到极致，比onCreate更早。
2.通过**面向接口或者抽象编程**，可以避免在项目中需要用到插件中的类的时候只能进行反射处理的问题。
3.Android Studio中有六种依赖，后期Compile被改成implement和api：
- Compile：compile是对所有的build type以及favlors都会参与编译并且打包到最终的apk文件中。
- Provided：Provided是对所有的build type以及favlors只在编译时使用，类似eclipse中的external-libs,只参与编译，不打包到最终apk。
- APK：只会打包到apk文件中，而不参与编译，所以不能再代码中直接调用jar中的类或方法，否则在编译时会报错
- Test compile：仅仅是针对单元测试代码的编译编译以及最终打包测试apk时有效，而对正常的debug或者release apk包不起作用
- Debug compile：Debug compile 仅仅针对debug模式的编译和最终的debug apk打包。
- Release compile：仅仅针对Release 模式的编译和最终的Release apk打包。

典型的Binder模式,有利于后面的理解： 1、客户端通过某种方式得到服务器端的代理对象。从客户端角度看来代理对象和他的本地对象没有什么差别。它可以像其他本地对象一样调用其方法，访问其变量。 2、客户端通过调用服务器代理对象的方法向服务器端发送请求。 3、代理对象把用户请求通过Android内核（Linux内核）的Binder驱动发送到服务器进程。 4、服务器进程处理用户请求，并通过Android内核（Linux内核）的Binder驱动返回处理结果给客户端的服务器代理对象。 5、客户端收到服务器端的返回结果。

4.想要实现插件化，主要是解决下面三个问题：
插件中代码的加载和与主工程的互相调用
插件中资源的加载和与主工程的互相访问
四大组件生命周期的管理



### 资源初探
Resources类中的众多访问资源的方法，比如getColor，getText等方法，都是间接调用AssetManager的方法。AssetManager是最终的调用入口。AssetManager有一个addAssetPath方法，在App启动的时候，会当前Apk的路径传进去，这样就可以访问apk的资源了。所以我们可以通过反射的方式，把插件apk的路径传入这个方法，那么app的资源就都在一个资源池中了。

当我们使用R中的id去调用资源时，是使用Apk打包时候`aapt`的resources.arsc哈希表文件来获取id和资源的对应关系。

**所以当我们想要加载自己的dex中的资源时，需要自己生成一个AssetManager，基于这个AssetManager生成Resources，Theme，和Assets对象，并复写Activity的getAssets，getResources，getTheme方法**

资源通过`aapt`打包，所以我们可以在aapt打包生成resources.arsc之后，对resources.arsc进行修改，或者直接修改aapt。


### 最简单的插件化解决方案
最简单的方案有：
- 合并所有插件的dex，来解决插件的类的加载问题
- 预习在宿主的AndroidManifest中声明插件中的四大组件。
- 把插件中的资源也合并到宿主的资源中

以上就是说通过把ClassLoader中的pathList中的dexElements替换为我们原有的和新的插件的dex的list。

缺点是不够灵活，因为无法预声明插件中的四大组件。

### Activity的插件化解决方案
加载插件中类的方案有三：
- 基于动态替换：把插件apk对应的LoadedApk对象，直接放入缓存中，然后把LoadedApk对象的ClassLoader改为插件的ClassLoader。非常麻烦。
- 合并多个dex。也就是把插件的dex放在ClassLoader的dexList的最前面
- 修改App原生的ClassLoader

Activity可以使用多个Activity来占位处理，如果有LaunchMode的问题，还需要为占位的Activity预定义LaunchMode

### Service插件化解决方案
Service也需要占位。但是不像Activity。Service只能一对一占位。也就是说一个StubService只能对应一个插件中的Service。

### ContentProvider插件化
ContentProvider在加载插件时安装插件Provider

方案：
- 把宿主App和插件App的dex合并到一起
- 读取插件中的ContentProvider信息，借助PackageParser的parsePackage方法

### Boradcast插件化
静态广播以动态广播方式注册。

### Binder机制




### ClassLoader
ClassLoader:
PathClassLoader vs DexClassLoader区别是DexClassLoader可以加载任何路径的apk/dex/jar
PathClassLoader只能加载/data/app中的apk，也就是已经安装到手机中的apk。这个也是PathClassLoader作为默认的类加载器的原因，因为一般程序都是安装了，在打开，这时候PathClassLoader就去加载指定的apk(解压成dex，然后在优化成odex)就可以了。

类加载包括了包括加载、验证、准备、解析和初始化五个阶段；对于开发者来说，可控性最强的是加载阶段；加载阶段主要完成三件事：
- 根据一个类的全限定名来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为JVM方法区中的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。


