<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="keywords" content="Android">
<meta property="og:type" content="website">
<meta property="og:title" content="Coding and Learning">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Coding and Learning">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coding and Learning">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Coding and Learning</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coding and Learning</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">oubindo的技术与生活博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/04/C++自学笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/C++自学笔记/" itemprop="url">C++自学笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-04T09:09:44+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-自学笔记"><a href="#C-自学笔记" class="headerlink" title="C++自学笔记"></a>C++自学笔记</h2><h3 id="一-基础"><a href="#一-基础" class="headerlink" title="一. 基础"></a>一. 基础</h3><p>1.变量类型：在C的基础上添加了wchar_t。</p>
<p>2.变量声明：变量和函数声明只在编译时有意义，在程序连接时编译器需要实际的变量声明也就是变量定义。并且声明可以多次，但是变量定义只能一次。</p>
<p>extern修饰变量：用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> count ;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">write_extern</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   count = <span class="number">5</span>;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_extern</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Count is "</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static：存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>
<p>3.类型限定符：</p>
<table>
<thead>
<tr>
<th>const</th>
<th><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</th>
</tr>
</thead>
<tbody>
<tr>
<td>volatile</td>
<td>修饰符 <strong>volatile</strong> 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</td>
</tr>
<tr>
<td>restrict</td>
<td>由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td>
</tr>
</tbody>
</table>
<p>4.函数</p>
<p>默认函数：您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。<strong>注意：这里的默认参数必须放在普通参数之后</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b=<span class="number">20</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  result = a + b;</span><br><span class="line">  <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的三种传值方式：</p>
<ul>
<li>传值调用：把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</li>
<li>指针调用把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</li>
<li>引用调用：把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</li>
</ul>
<p>5.字符串</p>
<p>C风格: char a[10] = “hello”;</p>
<p>C++风格: string a = “s d” + “ ds”;</p>
<h3 id="二-指针与数据结构"><a href="#二-指针与数据结构" class="headerlink" title="二. 指针与数据结构"></a>二. 指针与数据结构</h3><p>1.指针的声明，赋值和取值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var = <span class="number">20</span>;   <span class="comment">// 实际变量的声明</span></span><br><span class="line">   <span class="keyword">int</span>  *ip;        <span class="comment">// 指针变量的声明</span></span><br><span class="line">   ip = &amp;var;       <span class="comment">// 在指针变量中存储 var 的地址 </span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of var variable: "</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; var &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出在指针变量中存储的地址</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Address stored in ip variable: "</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 访问指针中地址的值</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of *ip variable: "</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; *ip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。</p>
<p>2.在函数参数列表中的两种表示方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span>  <span class="comment">// 引用传值，这里&amp;x表示的是传入的参数是一个值，可以直接使用，或者用&amp;取出这个参数的指针</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_2</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span>  <span class="comment">// 指针传值，这里*x代表传入的参数是一个指针，可以直接使用，或者用*取出这个参数的值</span></span></span><br></pre></td></tr></table></figure>
<p>3.指针可以进行数学比较，毕竟都是指针。</p>
<p>4.指针数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr[MAX]  <span class="comment">// 指针数组</span></span><br><span class="line"><span class="keyword">int</span> (*ptr)[MAX] <span class="comment">// 数组指针</span></span><br></pre></td></tr></table></figure>
<p>5.函数中返回指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">function</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>结构变量用.来引出结构中的成员，结构变量指针用-&gt;来引出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">( struct Books *book )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Books Book1;        <span class="comment">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class="line">   Books Book2;        <span class="comment">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Book1 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">"C++ 教程"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">"Runoob"</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">"编程语言"</span>);</span><br><span class="line">   Book1.book_id = <span class="number">12345</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Book2 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">"CSS 教程"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">"Runoob"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">"前端技术"</span>);</span><br><span class="line">   Book2.book_id = <span class="number">12346</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 通过传 Book1 的地址来输出 Book1 信息</span></span><br><span class="line">   printBook( &amp;Book1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 通过传 Book2 的地址来输出 Book2 信息</span></span><br><span class="line">   printBook( &amp;Book2 );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该函数以结构指针作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">( struct Books *book )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"书标题  : "</span> &lt;&lt; book-&gt;title &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"书作者 : "</span> &lt;&lt; book-&gt;author &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"书类目 : "</span> &lt;&lt; book-&gt;subject &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"书 ID : "</span> &lt;&lt; book-&gt;book_id &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三-类和对象"><a href="#三-类和对象" class="headerlink" title="三. 类和对象"></a>三. 类和对象</h3><p>1.继承：C++类定义及使用与Java十分相似，但是引入了继承方式的区别, 规则是：</p>
<blockquote>
<p><strong>public 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</p>
<p><strong>protected 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</p>
<p><strong>private 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</p>
</blockquote>
<p>看个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  A()&#123;</span><br><span class="line">    a1 = <span class="number">1</span>;</span><br><span class="line">    a2 = <span class="number">2</span>;</span><br><span class="line">    a3 = <span class="number">3</span>;</span><br><span class="line">    a = <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//正确</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a1 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//正确</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a2 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//正确</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a3 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//正确</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> a2;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">protected</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  B(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    A();</span><br><span class="line">    a = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//正确，public成员。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a1 &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a2 &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a3 &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//错误，基类的private成员不能被派生类访问。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; b.a &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//正确。public成员</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; b.a1 &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//错误，protected成员不能在类外访问。</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; b.a2 &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//错误，protected成员不能在类外访问。</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; b.a3 &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//错误，private成员不能在类外访问。</span></span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类中变量和函数声明也要使用这三个修饰符。并且默认是private。</p>
<p>2.C++同时引入了析构函数，用于在删除对象的时候运行。C++类会自动控制类的空间的申请和释放。所以析构函数就是在这个时候调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Line::Line(<span class="keyword">double</span> len);</span><br><span class="line">~Line:Line();</span><br></pre></td></tr></table></figure>
<p>3.拷贝构造函数</p>
<p><strong>拷贝构造函数</strong>是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p>
<ul>
<li>通过使用另一个同类型的对象来初始化新创建的对象。</li>
<li>复制对象把它作为参数传递给函数。</li>
<li>复制对象，并从函数返回这个对象。</li>
</ul>
<p>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classname (<span class="keyword">const</span> classname &amp;obj) &#123;    <span class="comment">// 构造函数的主体 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如接下来的例子给出了三者组合的使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 为指针分配内存</span></span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *ptr = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Line::Line(<span class="keyword">const</span> Line &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数并为指针 ptr 分配内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *ptr = *obj.ptr; <span class="comment">// 拷贝值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Line::~Line(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"释放内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.指向类的指针需要使用成员访问运算符-&gt;，就像指向结构的指针一样使用。</p>
<p>5.类的静态成员数据：</p>
<p>与Java不同的地方是不能把静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 <strong>::</strong> 来重新声明静态变量从而对它进行初始化，函数也是如此：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> objectCount;</span><br><span class="line">      <span class="comment">// 构造函数定义</span></span><br><span class="line">      Box(<span class="keyword">double</span> l=<span class="number">2.0</span>, <span class="keyword">double</span> b=<span class="number">2.0</span>, <span class="keyword">double</span> h=<span class="number">2.0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt;<span class="string">"Constructor called."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">         length = l;</span><br><span class="line">         breadth = b;</span><br><span class="line">         height = h;</span><br><span class="line">         <span class="comment">// 每次创建对象时增加 1</span></span><br><span class="line">         objectCount++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">Volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> objectCount;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;     <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;    <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;     <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始化类 Box 的静态成员</span></span><br><span class="line"><span class="keyword">int</span> Box::objectCount = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 在创建对象之前输出对象的总数</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Inital Stage Count: "</span> &lt;&lt; Box::getCount() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="function">Box <span class="title">Box1</span><span class="params">(<span class="number">3.3</span>, <span class="number">1.2</span>, <span class="number">1.5</span>)</span></span>;    <span class="comment">// 声明 box1</span></span><br><span class="line">   <span class="function">Box <span class="title">Box2</span><span class="params">(<span class="number">8.5</span>, <span class="number">6.0</span>, <span class="number">2.0</span>)</span></span>;    <span class="comment">// 声明 box2</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 在创建对象之后输出对象的总数</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Final Stage Count: "</span> &lt;&lt; Box::getCount() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.<strong>运算符重载</strong></p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>
<p>7.<strong>虚函数</strong></p>
<p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。也就是说，虚函数的调用不是在编译时刻确定的，而是在运行时刻确定的</p>
<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>
<p>虚函数有点类似于Java中的可以重写的函数。Java之中可以重写的函数都是运行时候确定的，</p>
<p>如果不想给一个虚函数给出实现，就定为纯需函数。纯虚函数有点像接口的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getVolume</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>8.接口和抽象类</p>
<p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的。</p>
<h2 id="四-高级"><a href="#四-高级" class="headerlink" title="四.高级"></a>四.高级</h2><h3 id="1-文件操作"><a href="#1-文件操作" class="headerlink" title="1.文件操作"></a>1.文件操作</h3><p>文件操作头文件</p>
<ul>
<li>ofstream：输出文件流</li>
<li>ifstream：输入文件流</li>
<li>fstream：文件流，拥有输入输出的功能</li>
</ul>
<p>2.在从文件读取信息或者向文件写入信息之前，必须先打开文件。<strong>ofstream</strong> 和 <strong>fstream</strong> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <strong>ifstream</strong> 对象。</p>
<p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里的openmode指明了打开的模式</p>
<table>
<thead>
<tr>
<th>模式标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ios::app</td>
<td>追加模式。所有写入都追加到文件末尾。</td>
</tr>
<tr>
<td>ios::ate</td>
<td>文件打开后定位到文件末尾。</td>
</tr>
<tr>
<td>ios::in</td>
<td>打开文件用于读取。</td>
</tr>
<tr>
<td>ios::out</td>
<td>打开文件用于写入。</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td>
</tr>
</tbody>
</table>
<p>打开以后使用 &gt;&gt; 和 &lt;&lt; 进行数据的写入与读出。与cout cin类似。</p>
<h3 id="2-C-动态内存"><a href="#2-C-动态内存" class="headerlink" title="2. C++动态内存"></a>2. C++动态内存</h3><p><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</p>
<p><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</p>
<p>通常使用new和delete运算符来申请和删除内存。</p>
<p>如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">double</span>* pvalue  = <span class="literal">NULL</span>; <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">   pvalue  = <span class="keyword">new</span> <span class="keyword">double</span>;   <span class="comment">// 为变量请求内存</span></span><br><span class="line">   *pvalue = <span class="number">29494.99</span>;     <span class="comment">// 在分配的地址存储值</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of pvalue : "</span> &lt;&lt; *pvalue &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">delete</span> pvalue;         <span class="comment">// 释放内存</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-模板"><a href="#3-模板" class="headerlink" title="3.模板"></a>3.模板</h3><p>C++模板和Java模板语法很像。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;left, <span class="keyword">const</span> T &amp;right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (right &lt; left)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   <span class="built_in">vector</span>&lt;T&gt; elems; <span class="comment">// 元素</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span> &amp;)</span></span>; <span class="comment">// 入栈</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;           <span class="comment">// 出栈</span></span><br><span class="line">   <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">// 返回栈顶元素</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">   </span>&#123; <span class="comment">// 如果为空则返回真。</span></span><br><span class="line">      <span class="keyword">return</span> elems.empty();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-线程"><a href="#4-线程" class="headerlink" title="4.线程"></a>4.线程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS     5</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="keyword">void</span> *threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="comment">// 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取</span></span><br><span class="line">   <span class="keyword">int</span> tid = *((<span class="keyword">int</span>*)threadid);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello Runoob! 线程 ID, "</span> &lt;&lt; tid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">   <span class="keyword">int</span> indexes[NUM_THREADS];<span class="comment">// 用数组来保存i的值</span></span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;      </span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"main() : 创建线程, "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      indexes[i] = i; <span class="comment">//先保存i的值</span></span><br><span class="line">      <span class="comment">// 传入的时候必须强制转换为void* 类型，即无类型指针        </span></span><br><span class="line">      rc = pthread_create(&amp;threads[i], <span class="literal">NULL</span>, </span><br><span class="line">                          PrintHello, (<span class="keyword">void</span> *)&amp;(indexes[i]));</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error:无法创建线程,"</span> &lt;&lt; rc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/也谈谈我的2018/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/也谈谈我的2018/" itemprop="url">也谈谈我的2018</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-02T10:15:00+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/年度总结/" itemprop="url" rel="index">
                    <span itemprop="name">年度总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="也谈谈我的2018"><a href="#也谈谈我的2018" class="headerlink" title="也谈谈我的2018"></a>也谈谈我的2018</h2><p>年轻的时候喜欢写一些文章，喜欢铺垫一些比较煽情的气氛，喜欢总结一些看似很有道理的经验。越到年纪大了，越觉得生活就是很平平淡淡的事。尤其是进入社会以来，除去工作以外生活所给的反馈越来越少。更让我加深了这种感慨。有时候就容易感叹：生活真是索然无趣啊。</p>
<p>于是就想着求变。想着2018年没有做好的事情，2019年要用更大的激情和努力来完成，哪怕并没有达到自己年初的预期，想来也总算有个盼头。就像小的时候盼着过年，读书的时候盼着高考一样，进入社会了总不能盼着早点退休吧。咳咳。</p>
<p>我以为回顾起我的2018，会像某些朋友一样：这是xxxx的一年，也是xxxx的一年。但是对我来说，2018年过的有点太快了。快到我没有好好体会就结束了。毕业论文，答辩，适应工作。我现在只能想起这几个词。毕业论文选择了做一点偏研究性的工作，想体会一下真正的科研人员们的快乐，提升一下自己的研究能力，然后那段时间就是疯狂的看论文，想idea。结果终究还是有点准备不足，就算花了很多的时间还是没有达到比较好的效果。但是也推翻了自己对自己的一种固有观念：不喜欢搞科研。人生还是有无限可能的。不想自己给自己设限。从此以后，应该会去追求更多的可能性和多样性吧。</p>
<p>临到毕业的时候想着出国去做做义工旅行，困于囊中羞涩打消了计划。其实内心里还是很想去的。想去老挝的琅勃拉邦，过一段时间日出而作日落而息的生活。远离手机和电脑，多点对自己人生的思考。这一点其实也是对自己大学的不满。感觉大学期间的自己浑浑噩噩，很多事情都没有做到过自己能力范围内的最好，与自己的预期相差甚远。加权没有进入前十，没有好好利用图书馆，没有去做一件让自己离开大学也会念念不忘的大事。甚至于自己拿来谋生的技能，自己也不算做的很好，学习精力分散，杂而不精。更重要的是，内心变得十分的浮躁，越来越少的思考，经常直接接受不用消化的信息和知识。总想有段时间能进行反思总结，结果没能去成。没去成也就罢了吧。自己慢慢的去改正吧。这半年来也已经慢慢改了不少了。</p>
<p>进入工作以来，自己进入了一个适应期。如何跟同事沟通，如何完成上级分配的任务，如何摆正自己的心态，如何规划自己的未来道路，如何更快更好的提升自己。十分感谢导师和leader对我的帮助。我感觉慢慢适应了自己的工作，也对自己的未来慢慢的有了一些规划和安排。进入头条感觉很幸运，同时也感觉很有挑战。每天都下班很晚，周末还经常加班。大家都是抱着对项目的期待在努力着。对于我来说，必须自己粗心，做事不细致不严谨的毛病，慢慢成为一个踏实靠谱，能独当一面的人。过几天我的试用期就结束了，希望不要被裁掉。哈哈。也希望新的一年，自己能尽快成长，进步的速度大于头发脱落的速度。</p>
<p>这一年里感情方面跟女朋友关系也算磨合的更有默契了。两个人都对对方有了更深的了解，所以对两个人在一起的状态也有了更多的思考。两个人性格都偏温和，平时也没啥吵闹，凡事商量着来。尽量去礼让对方。分手几次后，争吵的更少了，也算是带来了一些益处。</p>
<p>按照我司OKR的评价标准评价自己的2018年，我打个6.5分。各方面都有较高的努力空间。未来可期。</p>
<p>2019年，对于自己的期望是把现在的一些能做的事做到最好。思想上能摒弃一些无益的糟粕，兴趣爱好能有一些拿得出手的成就。事业上成长的足够快，生活上更有规律更健康，感情上更成熟稳定。我也立个okr吧，明年今天复验，完不成的话，就罚自己吃公司健康餐一个月。</p>
<p>2019年 OKR:</p>
<ol>
<li>github上有一两个长久维护的库，能跟着自己的技术成长的那种。阅读至少20个优秀开源库源码</li>
<li>按照自定的计划继续坚持健身。今年的目标是体重达到65kg或体脂率达到13，身材匀称。</li>
<li>学完《吉他自学三月通》，滑板学会ollie和一些中低级动作</li>
<li>更深入的学习MMA。项目空闲后每周周末一次实战。</li>
<li>每月看一本专业无关的闲书。</li>
<li>早睡早起，养成为革命持续奋斗的作息习惯。持续养生，不做地中海！</li>
</ol>
<p>2019，冲鸭！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/30/Java知识深入/你所不知道的Method Handles/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/30/Java知识深入/你所不知道的Method Handles/" itemprop="url">你所不知道的Method Handles</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-30T10:15:00+08:00">
                2018-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Method-Handles"><a href="#Method-Handles" class="headerlink" title="Method Handles"></a>Method Handles</h2><p>Method Hanldes是在Java 7引入的概念。全限定名是java.lang.invoke.MethodHandles。在这篇文章中，我们将学会如何创建，使用MethodHandles及它的原理。</p>
<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>Method Handles的引入是为了与已经存在的java.lang.reflect API相配合。他们分别是为了解决不同的问题而出现的。从性能角度上说，MethodHandle api要比反射快很多因为访问检查在创建的时候就已经完成了，而不是像反射一样等到运行时候才检查。但同时，Method Handles比反射更难用，因为没有列举类中成员，获取属性访问标志之类的机制。<br>另外，MethodHandles可以操作方法，更改方法参数的类型和他们的顺序。而反射则没有这些功能。<br>从以上角度看，反射更通用，但是安全性更差，因为可以在不授权的情况下使用反射对象。而method Handles遵从了分享者的能力。所以method handle是一种更低级的发现，适配和调用方法的方式，唯一的优点就是更快。所以反射更适合主流Java开发者，而method handle更适用于对编译和运行性能有要求的人。</p>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><p>1.要使用method handle，首先需要得到Lookup。这是创造方法，构造函数，属性的method handles的工厂类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public方法的Lookup</span></span><br><span class="line">MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();</span><br><span class="line"><span class="comment">// 所有方法的Lookup</span></span><br><span class="line">MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br></pre></td></tr></table></figure></p>
<p>2.要创建MethodHandle，lookup需要一个定义了它的类型的MethodType对象。这里的类型包括了传入参数的类型，和最后返回的类型，要一一对应。第一个是返回类型，如果没有返回值就是Void.class, 后面是可变的传入参数的类型。</p>
<blockquote>
<p> a MethodType represents the arguments and return type accepted and returned by a method handle or passed and expected by a method handle caller.</p>
</blockquote>
<p>例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数组，返回一个List对象</span></span><br><span class="line">MethodType mt = MethodType.methodType(List.class, Object[].class);</span><br></pre></td></tr></table></figure></p>
<p>3.查找MethodHandle<br>Lookup之所以叫Lookup自然是因为他们有查找MethodHandle的能力。先看看他的方法。<br><img src="http://ovkwd4vse.bkt.clouddn.com/屏幕快照 2018-10-19 上午10.19.20.png" alt="屏幕快照 2018-10-19 上午10.19.20.png"></p>
<p>4.接下来就可以进行查找并调用了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MethodType mt = MethodType.methodType(String.class, <span class="keyword">char</span>.class, <span class="keyword">char</span>.class);</span><br><span class="line">MethodHandle replaceMH = publicLookup.findVirtual(String.class, <span class="string">"replace"</span>, mt);</span><br><span class="line"> </span><br><span class="line">String output = (String) replaceMH.invoke(<span class="string">"jovo"</span>, Character.valueOf(<span class="string">'o'</span>), <span class="string">'a'</span>);</span><br></pre></td></tr></table></figure></p>
<p>5.方法调用细则：<br>有三种方法可以调用方法invoke(), invokeWithArugments()和invokeExact()，当我们使用invoke时，我们必须固定arguments的数目。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invoke使用</span></span><br><span class="line">MethodType mt = MethodType.methodType(String.class, <span class="keyword">char</span>.class, <span class="keyword">char</span>.class);</span><br><span class="line">MethodHandle replaceMH = publicLookup.findVirtual(String.class, <span class="string">"replace"</span>, mt);</span><br><span class="line">String output = (String) replaceMH.invoke(<span class="string">"jovo"</span>, Character.valueOf(<span class="string">'o'</span>), <span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// invokeWithArguments使用</span></span><br><span class="line">MethodType mt = MethodType.methodType(List.class, Object[].class);</span><br><span class="line">MethodHandle asList = publicLookup.findStatic(Arrays.class, <span class="string">"asList"</span>, mt);</span><br><span class="line">List&lt;Integer&gt; list = (List&lt;Integer&gt;) asList.invokeWithArguments(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// invokeExact</span></span><br><span class="line">MethodType mt = MethodType.methodType(<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">MethodHandle sumMH = lookup.findStatic(Integer.class, <span class="string">"sum"</span>, mt);</span><br><span class="line"><span class="keyword">int</span> sum = (<span class="keyword">int</span>) sumMH.invokeExact(<span class="number">1</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure></p>
<p>具体的区别是：</p>
<blockquote>
<p>与invokeExact方法不同，invoke方法允许更加松散的调用方式。它会尝试在调用的时候进行返回值和参数类型的转换工作。这是通过MethodHandle类的asType方法来完成的，asType方法的作用是把当前方法句柄适配到新的MethodType上面，并产生一个新的方法句柄。当方法句柄在调用时的类型与其声明的类型完全一致的时候，调用invoke方法等于调用invokeExact方法；否则，invoke方法会先调用asType方法来尝试适配到调用时的类型。如果适配成功，则可以继续调用。否则会抛出相关的异常。这种灵活的适配机制，使invoke方法成为在绝大多数情况下都应该使用的方法句柄调用方式。</p>
</blockquote>
<p>参考：<br><a href="https://www.baeldung.com/java-method-handles" target="_blank" rel="noopener">https://www.baeldung.com/java-method-handles</a><br><a href="https://www.cnblogs.com/night-wind/p/4405564.html" target="_blank" rel="noopener">https://www.cnblogs.com/night-wind/p/4405564.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/30/书海拾贝/自控力/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/30/书海拾贝/自控力/" itemprop="url">自控力</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-30T10:15:00+08:00">
                2018-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/书籍/" itemprop="url" rel="index">
                    <span itemprop="name">书籍</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="自控力"><a href="#自控力" class="headerlink" title="自控力"></a>自控力</h2><p>这一周终于把拖了很久没看的自控力看完了。用一句话来归纳自己的所得，可以总结为：感觉自己学习到了什么，又好像啥都没学到，又好像见识到了什么，但是对自己来说又有好多的争议点。下面我会针对自己的一些摘录，提供一些自己的思考，由于是第一次这样去做，可能还是不够完善。</p>
<h3 id="摘录及有得"><a href="#摘录及有得" class="headerlink" title="摘录及有得"></a>摘录及有得</h3><p>是非判断对自控力的影响：<br>1.当说到孰是孰非时，我们都能毫不费力地作出符合道德标准的选择。我们只想让自己感觉良好，而这就为自己的胡作非为开了绿灯。<br>2.只要我们的思想中存在正反两方，好的行为就总是允许我们做一点坏事<br>3.不要把支持目标实现的行为误认为是目标本身。不是说你做了一件和你目标一致的事情，你就不会再面临危险了。注意观察一下，你是否因为认为某些积极的行为值得称赞，就忘了自己实际的目标是什么。</p>
<blockquote>
<p>当我们把事情分割成正反两方时候，我们就很容易为了一点好处而搭上另外一些代价。或者说是更心安理得的去接收一些对我们自控有害的东西。比如标注了低糖的可乐总是会成功的俘获减肥的我们。减肥期的人本来就不应该喝可乐，低糖成功的降低了我们的注意力。</p>
</blockquote>
<p>关注过程对自控力的影响：<br>1.虽然这个观点不符合我们对“完成目标”的看法，但关注进步确实会让我们离成功越来越远。这不是说进步本身是个问题，问题在于进步给我们带来的感觉。更进一步说，问题是我们不能坚持自己的目标，而会听从自己的感觉。进步可以激励人，甚至可以提高未来的自控力，但前提是，你要把自己的行动当做努力完成目标的证据。<br>2.不要把支持目标实现的行为误认为是目标本身。不是说你做了一件和你目标一致的事情，你就不会再面临危险了。注意观察一下，你是否因为认为某些积极的行为值得称赞，就忘了自己实际的目标是什么。<br>3.虽然这个观点不符合我们对“完成目标”的看法，但关注进步确实会让我们离成功越来越远。这不是说进步本身是个问题，问题在于进步给我们带来的感觉。更进一步说，问题是我们不能坚持自己的目标，而会听从自己的感觉。进步可以激励人，甚至可以提高未来的自控力，但前提是，你要把自己的行动当做努力完成目标的证据。</p>
<blockquote>
<p>当我们要实现某个目标时，如果计划比较长远，可以分解成一步一步的小台阶，关注自己在每个小台阶上得到的进步，这样会让我们更有攀登高峰的决心。但是我们同样要有意识，我们的小进步并不是目标本身，我们依然要以长远为导向</p>
</blockquote>
<p>道德光环带来的影响：<br>1.这种“道德许可”的形式为你对诱惑说“好的”提供了充足的理由。当我们想获得放纵许可的时候，我们会寻找任何一个美德的暗示，为自己放弃抵抗作辩护。<br>2.只要使你放纵的东西和使你觉得品德高尚的东西同时出现，就会产生光环效应。比如，研究人员发现，出于慈善目的购买巧克力的人，会吃更多的巧克力来奖励自己的善行</p>
<blockquote>
<p>给自己带上一层道德光环，就容易放任自己做一些坏事</p>
</blockquote>
<p>多巴胺与奖励系统对自控力的影响：<br>1.我们会发现，在追求幸福的时候，我们可不能相信大脑指引的方向。我们还会发现，神经营销学这个全新领域是如何利用这个原理来操控我们的大脑、为我们制造欲望的，以及我们如何才能抵抗这种欲望。<br>2.奖励系统是怎么迫使我们行动的呢？当大脑发现获得奖励的机会时，它就释放出叫做多巴胺的神经递质。多巴胺会告诉大脑其他的部分它们需要注意什么，怎样才能让贪婪的我们得手<br>3.克努森证明了，多巴胺控制的是行动，而不是快乐。奖励的承诺保证了被试者成功地行动，从而获得奖励。当奖励系统活跃的时候，他们感受到的是期待，而不是快乐。<br>4.现代科技“及时行乐”的特点，加上原始的激励系统，就让我们成了多巴胺的奴隶，从此欲罢不能。我们中的一些人应该还记得那种狂按电话答录机按钮、查收新消息的刺激感。后来，我们又通过调制解调器连上了美国在线，希望电脑会告诉我们：“你收到了新邮件！”好吧，我们现在有了Facebook、Twitter、电子邮件和短信息——这就是精神病专家罗伯特·希斯设计的自我刺激设备的现代版<br>5.<strong>难以预料的，经常变化的奖励比通常的奖励更有吸引力</strong><br>6.奖励的承诺有很大的力量，它会让我们继续追求那些不会带给我们快乐的东西，会让我们消费那些不会带来满足感，只会带来更多痛苦的东西。追求奖励是多巴胺的主要目标，所以，即便你经历的事物和原本承诺的并不相符，它也不会给你释放“停下来”的信号。<br>7.奖励系统也很重要：快感缺乏的人认为生活就是一系列的习惯，他们没有对满足感的期待。他们可以吃东西、购物、社交，甚至有性生活，但不会期待从中获得快乐。当他们不再需要快感的时候，他们就失去了动力。如果你想不出任何一件让你感觉良好的事，你就很难从床上爬起来做事。这种毫无欲望的状态耗尽了希望，也夺走了很多人的生命。</p>
<blockquote>
<p>很多时候我们都是被奖励系统驱使着。比如游戏，冲动的犯罪，当我们每次被奖励系统驱使着的时候，只要质问一下自己：这真的会让我快乐吗？应该就能更好的自控。但是这奖励系统又太过于重要，是一个人追求幸福不能缺少的东西，不然人生就会毫无干劲</p>
</blockquote>
<p>压力对自控力的影响：<br>1.为什么压力会带来欲望呢？因为这是大脑援救任务的一部分。此前，我们看到了压力是如何引发应激反应的。应激反应是身体内部相互协调的一系列变化，让你能在面临危险的时候保护自己。但人脑不仅仅会保护人的生命，它也想维持人的心情。所以，当你感到压力时，你的大脑就会指引着你，让你去做它认为能带给你快乐的事情。<br>2.有效和无效的策略最主要的区别是什么？真正能缓解压力的不是释放多巴胺或依赖奖励的承诺，而是增加大脑中改善情绪的化学物质，<br>3.美国心理学家协会的调查发现，最有效的解压方法包括：锻炼或参加体育活动、祈祷或参加宗教活动、阅读、听音乐、与家人朋友相处、按摩、外出散步、冥想或做瑜伽，以及培养有创意的爱好。<br>4.我们有时候产生强烈的不适感，或者我们并不知道这是为什么。即使我们意识不到这种恐惧，它还是会让我们立即作出回应，对抗自己的无力感。我们会去寻找保护伞，寻找任何能让自己觉得安全、有力量、得到安慰的东西。<br>5.屈服会让你对自己失望，会让你想做一些改善心情的事。那么，最廉价、最快捷的改善心情的方法是什么？往往是做导致你情绪低落的事。</p>
<p>延迟满足感：<br>1.经济学家称之为“延迟折扣”。也就是说，等待奖励的时间越长，奖励对你来说价值越低。很小的延迟就能大幅降低你感知到的价值。<br>2.对那些想延迟快感的人来说，这是个好消息。只要你能创造一点距离，就会让拒绝变得容易起来。比如，一项研究发现，把糖果罐放在桌子的抽屉里，而不是直接放在桌上，会让办公室职员少吃1/3的糖。<br>3.想获得一个冷静明智的头脑，我们就需要在所有诱惑面前安排10分钟的等待时间。如果10分钟后你仍旧想要，你就可以拥有它。</p>
<blockquote>
<p>当我们确实想要打破自己的计划的时候，延迟十分钟思考一下。在制定计划的时候，也要考虑到让自己和诱惑的距离远一点。</p>
</blockquote>
<p>总是期待未来：<br>1.如果我们真的指望未来的自己能这么崇高，我们确实可以相信，未来的自己能做好所有的事。但更典型的情况是，当我们到了未来，理想中“未来的自己”却不见了，最后作决定的还是毫无改变的曾经的自己。即便我们现在已经失去了自控力，我们仍然愚蠢地希望未来的自己不会面临冲突。<br>2.向未来的自己描述一下自己现在将要做什么，有助于你实现长期目标。你对未来的自己有什么希望？你觉得自己会变成什么样？你也可以想象未来的自己回头看现在的自己。未来的自己会因为现在的自己做了什么而表示感激？</p>
<blockquote>
<p>把希望和努力放在现在，而把享受留给明天</p>
</blockquote>
<p>社会对我们的控制力的影响：<br>1.实际在很大程度上，那些我们通常认为受自控力影响的行为，也会受社会控制力的影响。我们愿意相信，我们的决定不会受他人的影响，我们为自己的独立和自由意志感到自豪。<br>2.在考虑如何作出选择时，我们经常想象自己是别人评估的对象。研究发现，这为人们自控提供了强大的精神支持。预想自己实现目标（比如戒烟或献血）后会非常自豪的人，更有可能坚持到底并获得成功，预想自己的行为会受到谴责也很有效。<br>3.为了让自豪感发挥作用，我们必须认为别人都在监视自己，或我们有机会向别人报告自己的成功。市场研究人员发现，人们在公开场合更愿意购买绿色产品，比他们私下网购时买得多。<br>4.当人们试着不去想某件事时，反而会比没有控制自己的思维时想得更多，比自己有意去想的时候还要多。这个效应在人处于紧张、疲劳或烦乱状态时最为严重。韦格纳把这个效应称为“讽刺性反弹”（<br>5.避免讽刺性反弹 怎么才能找到摆脱这种困境的方法呢？韦格纳提出了一种对抗讽刺性反弹的方法。这个方法本身就很有讽刺意味——这个方法就是放弃自控。当人们不再试图控制那些不希望出现的想法和情绪时，它们也就不会再来烦你了。大脑激活研究证实，一旦允许研究对象把压抑的想法表达出来，这个想法就不太容易被激活了，因此进入意识的可能性也变小了。这件事说起来有点矛盾——允许你去想一件事，反而会减少你想起它的可能性。</p>
<blockquote>
<p>这个点也很新颖。但是也确实是这样的。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/19/从0到1完成一个健身App/从0到1之二：路由框架设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/19/从0到1完成一个健身App/从0到1之二：路由框架设计/" itemprop="url">从零到一完成一个健身App之二：路由框架设计(未完成)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-19T10:15:00+08:00">
                2018-09-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/从零到一健身App/" itemprop="url" rel="index">
                    <span itemprop="name">从零到一健身App</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从零到一完成一个健身App之二：路由框架设计"><a href="#从零到一完成一个健身App之二：路由框架设计" class="headerlink" title="从零到一完成一个健身App之二：路由框架设计"></a>从零到一完成一个健身App之二：路由框架设计</h1><h2 id="1-路由框架的相关背景"><a href="#1-路由框架的相关背景" class="headerlink" title="1.路由框架的相关背景"></a>1.路由框架的相关背景</h2><p>路由框架是组件化大背景下出现的一种成熟方案。</p>
<p>相信有过组件化开发经验的同学都会知道，如果我们想在Module A中打开Module B中的Activity，这时候的Activity是找不到引用的。显式跳转是行不通的。另外，在很多时候我们都需要后台来动态确定我们需要跳转到什么页面。比如常见的分享码等。除此之外，H5页面越来越多，而H5页面是没办法通过startActivity跳到原生页面的。所以在这种情况下需要定义一种更适合组件化的，更灵活的路由方式。</p>
<p>为了找到这种方式，我们经历了以下过程</p>
<ol>
<li>隐式意图Activity跳转：依赖于Manifest文件的修改，并且参数不方便传递。使用了startActivity之后就无法插手任何环节了，就无法在跳转失败的时候降级。</li>
<li>基于事件，广播或EventBus，这种情况下跳转流不容易监控，而且在跳转复杂的情况下接入维护成本较高</li>
<li>调用一个固定的方法：这种情况侵入性太强，所有Activity都要实现，改造起来困难，难于扩展。</li>
</ol>
<p>所以我们需要一个优秀的路由框架，要能够实现：</p>
<ul>
<li>通过与后台一起定义schema，可以达到按后台所需跳转到特定页面的需求，也可以和H5页面统一跳转方式</li>
<li>代码侵入性弱，调用方便。</li>
<li>接入方简单易用。</li>
<li>灵活，能针对特定需求进行特定的处理。比如我们常见的登录判断和权限检查等。</li>
</ul>
<p>具体到实现方面，要能做到：</p>
<ul>
<li>路由注册采用apt注解式自动生成，避免手动管理</li>
<li>参数依赖注入，自动保存，不再需要手动写onSaveInstance、onCreate(SaveInstace)、onNewIntent(Intent)、getQueryParamer等</li>
<li>能动态拦截和动态替换</li>
</ul>
<h2 id="2-现有框架调研"><a href="#2-现有框架调研" class="headerlink" title="2.现有框架调研"></a>2.现有框架调研</h2><p>当前比较知名的路由框架有：阿里的ARouter，美团的WMRouter，ActivityRouter.</p>
<h3 id="2-1-ARouter"><a href="#2-1-ARouter" class="headerlink" title="2.1 ARouter"></a>2.1 ARouter</h3><p>ARouter有多个优势：<br>1.直接解析URL路由，解析参数并赋值到对应目标字段的页面中;<br>2.支持多模块项目;<br>3.支持InstantRun;<br>4.拦截器策略，允许自定义;<br>5.提供IoC容器,控制反转;<br>6.映射关系自动注册;<br>7.灵活的降级策略.</p>
<p>赶紧学习一下这些都是怎么做到的。先看一个示例<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/test/activity2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">ARouter.getInstance().build("/test/activity2")..withString("key1", "value1").navigation();</span><br></pre></td></tr></table></figure></p>
<p>再看看ARouter的架构。<br><img src="http://ovkwd4vse.bkt.clouddn.com/37b723fb660fdfcf7cdc09c194c88a8073d8272d.png" alt="37b723fb660fdfcf7cdc09c194c88a8073d8272d.png"></p>
<p>其中Compiler中三个处理器，分别是：<br>Route Processor：处理路径路由<br>Interceptor Processor：处理拦截器<br>Autowire Processor：进行自动装配</p>
<p>API中Launcher是用户可以调用的api所在的地方<br>Service是将功能和组件封装成的接口，对外开放。等到时候分析源码的时候要注意一下是怎么做到的。<br>Templete是用于SDK编译器生成映射文件时候提供的模板。<br>更下层的ware House: 存储了ARouter在运行期间加载的一些配置文件以及映射关系<br>Thread则是提供了线程池，因为存在多个拦截器的时候以及跳转过程中都是需要异步执行的<br>Class工具则是用于解决不同类型APK的兼容问题的。<br>再下一层就是Logistics Center，从名字上翻译就是物流中心，整个SDK的流转以及内部调用最终都会下沉到这一层, 也按功能模块划分。</p>
<p>一.如何实现解析URL路由，解析参数并赋值到目标字段中？<br>ARouter采用的是APT技术，通过定义的annotation来解析到相应的path。这里会遇到的第一个问题是找到处理注解的时机。运行期处理注解会大量的运用反射。所以要在编译期处理被注解的类。至于如何区分，就在于这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用来指明注解的访问范围</span></span><br><span class="line"><span class="comment">*  1.源码级注解SOURCE，该类型的注解信息会留在.java源码中，</span></span><br><span class="line"><span class="comment">*    源码编译后，注解信息会被丢弃，不会保留在编译好的.class文件中；</span></span><br><span class="line"><span class="comment">*  2.编译时注解CLASS，注解信息会保留在.java源码里和.class文件中，</span></span><br><span class="line"><span class="comment">*    在执行的时候，会被Java虚拟机丢弃不回家再到虚拟机中；</span></span><br><span class="line"><span class="comment">*  3.运行时注解RUNTIME，java源码里，.class文件中和Java虚拟机在运行期也保留注解信息，</span></span><br><span class="line"><span class="comment">*    可通过反射读取</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="comment">//是一个ElementType类型的数组，用来指定注解所使用的对象范围</span></span><br><span class="line"><span class="meta">@Target</span>(value = FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Add &#123;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">ele1</span><span class="params">()</span> <span class="keyword">default</span> 0f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">ele2</span><span class="params">()</span> <span class="keyword">default</span> 0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/17/从0到1完成一个健身App/从0到1之一：开篇词与项目总体架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/从0到1完成一个健身App/从0到1之一：开篇词与项目总体架构/" itemprop="url">从零到一完成一个健身App之一：开篇词和项目概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-17T10:15:00+08:00">
                2018-09-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/从零到一健身App/" itemprop="url" rel="index">
                    <span itemprop="name">从零到一健身App</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从零到一完成一个健身App"><a href="#从零到一完成一个健身App" class="headerlink" title="从零到一完成一个健身App"></a>从零到一完成一个健身App</h1><h2 id="一-开篇词"><a href="#一-开篇词" class="headerlink" title="一.开篇词"></a>一.开篇词</h2><p>我的计划是用一年半到两年的时间完成一个健身App。</p>
<p>1.目的：我是一个喜欢接受新技术的人。但是我又是一个很懒的人，这种懒惰体现在自己对于技术可能很多时候只限于使用的地步，而没有去深挖技术内部原理和实现细节，并且对于App的设计也缺乏一定的思考。现在自己已经在公司工作两个月了，从公司的项目中开阔了眼界。但是苦于没有地方练手。所以想找个App把自己学到的应用上来。目前来看，自己对于Android较为深入的技术都缺乏认知，都是需要强补的。这也是我想从头开始设计一个好的应用的原因。</p>
<p>2.项目现状与预期：这个应用是我为自己这种健身爱好者量身打造的应用，也打算部分参考keep和抖音的设计。之前未毕业前就有开始过这个项目的开发，但是当时因为毕业而搁置了。现在再拿出来看，当时的代码写的非常的傻逼。于是打算推翻重来。预期是：</p>
<ul>
<li>学会使用主流框架，如fresco，Architecture Component，RxJava等。</li>
<li>结合组件化和插件化，热修复等技术</li>
<li>对于一些较为简单的工具，如路由框架，能自行编写</li>
<li>关注性能优化</li>
<li>在项目的一些模块中能接触到深度学习。做一个AI赋能的App</li>
</ul>
<p>3.项目计划：因为现在在公司项目中确实压力比较大，10，10，大小周。目前来看，自己能用在这个项目上的时间是早上的八点半到十点。晚上的十点四十到十一点四十。周末也有时间可以搞一搞。考虑到自己可能需要学习很多的知识，而且自己平时的时间也不一定能放到这个上面来，预计需要一年半到两年的时间里完成这个项目。在这两年里，我会每两周根据自己的项目情况完成一篇博客。因为是自己的项目，代码中不会出现公司的代码，所有的代码都是自己学习后产出的。也不希望有人将我这项目用于商业目的。</p>
<p>4.专栏适合的人群：</p>
<ul>
<li>有一定Android开发经验，处于Android基础和进阶之间的人</li>
<li>想通过一个完整项目接触到当前互联网公司里最火热的技术的人</li>
<li>作为Android开发，想接触到深度学习等在Android中应用的人</li>
<li>适用于想一步一步提升自己各方面Android技术的人</li>
</ul>
<h2 id="二。项目概述"><a href="#二。项目概述" class="headerlink" title="二。项目概述"></a>二。项目概述</h2><p>1.项目将会采用的总体架构：</p>
<ul>
<li><p>MVVM和Architecture Component：相信大家都知道有MVC，MVP，和MVVM三种架构，MVC就不说了，MVP在很长的一段时间里都是主流，但是已经体验过MVVM的我不可能再用MVP了-_- 。常用的MVVM框架有databinding，但是databinding会带来业务代码耦合进xml中的问题，扩展性也差。我决定使用google的Architecture Component。谷爹出品，值得信赖，而且还挺好用的，很多数据问题都得到了解决。</p>
</li>
<li><p>RxJava：Rxjava作为一个成熟的库，事件流和函数式编程的思想深入人心</p>
</li>
<li>okhttp+retrofit：这两个框架是当今大厂的主流网络框架，也是学习网络相关的重要入口，我会在基本使用的基础上去挖掘相关的值得学习和有亮点的地方。</li>
<li>fresco：这也是最强大和性能最好的图片框架了。</li>
<li>插件化+组件化+热修复：这三个是类似的，但是又有一些区别。我倾向于每种技术都自己实现一个框架，其中组件化的路由框架我是一定要写的，代码量并不多。其他的就等到时候再看，如果有时间就自己写一个。</li>
<li>AOP技术：主要是用来进行日志和自动埋点等。目前对这块不是特别熟悉，等到时候再考虑吧。</li>
<li>JNA：由于之前没怎么接触过JNI技术，对相关的技术都不是很了解。所以在这个项目中想加入一些特效相关的处理，这也是我的兴趣所在。不可避免的要使用到native方法。因此打算使用JNA这个库</li>
<li>深度学习框架：目前暂定ncnn，腾讯优图出品的开源深度学习框架，看评测是要强于目前所有已知开源框架。</li>
<li>数据库：因为Realm的一些坑，数据库框架打算采用GreenDao。</li>
<li>下载库：打算自己实现一个比较有意思的库。目前公司的项目有，自己可以吸收其精华，去掉自己不需要的部分。</li>
</ul>
<p>再次声明：本项目中不会有公司项目的源码，都是自己完成。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/我的gradle学习之路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/我的gradle学习之路/" itemprop="url">gradle学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-09T17:08:29+08:00">
                2018-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="gradle学习之路"><a href="#gradle学习之路" class="headerlink" title="gradle学习之路"></a>gradle学习之路</h2><p>1.gradle init生成gradle需要的文件。</p>
<p>2.gradle task –scan 可以生成报表，方便我们查看和分析什么耗时</p>
<p>3.build.gradle 里面写的是项目多模块可以同时使用的配置。当我们在这里加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter() </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>的时候，配置就对全局有效。也可以改成subprojects。而且这两个配置可以在根项目里使用很多次。</p>
<p>4.生成library： gradle init –type groovy-library/java-library/java-application</p>
<p>5.多个模块的通用设置放在根目录的build.gradle下面。可以用configure语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">configure(subprojects.findAll &#123; it.name == &apos;greeter&apos; || it.name == &apos;greeting-library&apos; &#125;) &#123; </span><br><span class="line"></span><br><span class="line">    apply plugin: &apos;groovy&apos;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        testCompile &apos;org.spockframework:spock-core:1.0-groovy-2.4&apos;, &#123;</span><br><span class="line">            exclude module: &apos;groovy-all&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6.只在根目录，进行其他subproject的编译<br>./gradlew :{subproject}/{task}</p>
<p>7.在Java library中进行build，可以在build/libs目录下找到jar。或者也可以使用./gradlew jar命令打jar包</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/10/美国大学Online课程推荐及个人评测/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/10/美国大学Online课程推荐及个人评测/" itemprop="url">美国大学Online课程及个人评测</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-10T13:28:32+08:00">
                2018-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="美国大学Online课程及个人评测"><a href="#美国大学Online课程及个人评测" class="headerlink" title="美国大学Online课程及个人评测"></a>美国大学Online课程及个人评测</h1><h2 id="已刷"><a href="#已刷" class="headerlink" title="已刷"></a>已刷</h2><p>1.Coursera MachineLearning：非常不错的机器学习入门课程，讲解细致，测验和program exercise都是很有效的补充学习资料。</p>
<p>2.Stanford MachineLearning：也是Ng的课程，但是这课程相对上门更难一点，有大量的数学证明，对于想要知根知底的学生来说是一个不错的补充学习资料。我只看了前10个讲座，后面的没看了。</p>
<h2 id="待刷"><a href="#待刷" class="headerlink" title="待刷"></a>待刷</h2><p>1.Coursera Algorithm II：</p>
<p>2.Coursera DeepLearning：</p>
<p>3.<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/index.htm" target="_blank" rel="noopener">MIT math for computer sciense</a> 这门课大多是离散数学的东西，可以等有空的时候再看，优先级低一些。</p>
<h2 id="外国公开课程地址"><a href="#外国公开课程地址" class="headerlink" title="外国公开课程地址"></a>外国公开课程地址</h2><p>1.<a href="https://ocw.mit.edu/courses/" target="_blank" rel="noopener">MIT open courses</a></p>
<p>2.<a href="https://www.cs.washington.edu/education/courses" target="_blank" rel="noopener">华盛顿大学 open courses </a><br>部分课程有视频在youtube上，很多的课程，几乎涵盖了所有课题。可以作为我以后刷课的主力。</p>
<p>3.直接搜课程英文名，然后看别人的推荐</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/10/kotlin深入学习系列(二)：类与对象篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/kotlin深入学习系列(二)：类与对象篇/" itemprop="url">Kotlin深入学习系列(二):OOP篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-10T13:38:32+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="一-类"><a href="#一-类" class="headerlink" title="一.类"></a>一.类</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在 Kotlin 中的一个类可以有一个主构造函数和一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（和可选的类型参数）后。其中由于主构造函数内不能写代码，主要的初始化代码需要在 init{} 中书写。在实例初始化期间，初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起。也就是说这里的<strong>初始化块init其实就是被当成了属性初始化</strong>。主构造函数中的参数默认为类参数使用。</p>
<p>次构造函数可以通过constructor(param)来定义，<strong>所有的构造函数都必须委托给主构造函数，可以直接委托或者通过别的次构造函数简洁委托。</strong> 委托方法是在constructor后面加个this()。</p>
<p>但是这里又有一个坑，次构造函数不能使用val或者var！例子如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Pair&lt;K, V&gt;(val first: K, val second: V) &#123;</span><br><span class="line"></span><br><span class="line">    init&#123;</span><br><span class="line">        println(<span class="string">"init"</span>)</span><br><span class="line">        println(first)</span><br><span class="line">        println(second)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(val first: K): <span class="keyword">this</span>(first, <span class="number">0</span>)&#123;    <span class="comment">// 这里的val报错。</span></span><br><span class="line">        println(<span class="string">"constructor"</span>)</span><br><span class="line">        println(first)</span><br><span class="line">        println(second)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Kotlin所有类都有一个超类Any。声明类时如果使用了open来修饰，那就可以被继承，否则默认不允许继承。</p>
<p>继承的时候如果子类有主构造函数，那么必须用父类的主构造函数参数初始化。否则必须有次构造函数调用super来调用父类的构造函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class HeritLearning: ClassLearning&#123;</span><br><span class="line">    constructor(name: String) : <span class="keyword">super</span>(name)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">class HeritLearning(name: String) : ClassLearning(name)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果一个方法同时和多个超类的相同，那就在调用父类方法的时候使用super&lt;父类&gt;.func()来区分父类。</p>
<h3 id="覆盖属性或方法"><a href="#覆盖属性或方法" class="headerlink" title="覆盖属性或方法"></a>覆盖属性或方法</h3><p>开放覆盖的属性和方法必须用open修饰，覆盖的必须用override修饰。覆盖属性的时候var可以覆盖val，反之则不行。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口默认为open，不需要主构造函数。</p>
<h2 id="二-字段"><a href="#二-字段" class="headerlink" title="二.字段"></a>二.字段</h2><p>字段的完整语法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure></p>
<p>也就是是说，当我们没有声明getter和setter时默认就已经有这些东西了。当我们声明以后可以得到自定义的实现。如果想屏蔽getter或者setter，可以使用private set。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var setterVisibility: String = <span class="string">"abc"</span></span><br><span class="line">    <span class="keyword">private</span> set <span class="comment">// 此 setter 是私有的并且有默认实现</span></span><br></pre></td></tr></table></figure></p>
<p>在访问器里面，我们可以使用field来代替此字段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var counter = <span class="number">0</span> <span class="comment">// 注意：这个初始器直接为幕后字段赋值</span></span><br><span class="line">    set(value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) field = value</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="lateinit"><a href="#lateinit" class="headerlink" title="lateinit"></a>lateinit</h3><p>属性初始化要点如下：</p>
<ul>
<li>当我们在类外面声明属性为可空或非空时，都必须进行初始化</li>
<li>声明为lateinit的对象必须是可空对象，非空对象不行。</li>
<li>使用.isInitialized来判断属性是否被初始化了。</li>
</ul>
<p><img src="http://ovkwd4vse.bkt.clouddn.com/markdown-img-paste-20180410161250423.png" alt=""></p>
<h2 id="三-扩展"><a href="#三-扩展" class="headerlink" title="三.扩展"></a>三.扩展</h2><p>所有扩展的定义域都在包里，使用之外的扩展就需要导入。</p>
<p>1.扩展函数<br>kotlin可以通过扩展来扩展类的新功能而无需继承或装饰。原理就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun ClassLearning.f(str: String)&#123;</span><br><span class="line">    <span class="keyword">this</span>.arr[<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">open class <span class="title">ClassLearning</span><span class="params">(val name: String, val age: Int)</span></span>&#123;</span><br><span class="line">    var arr = Array&lt;Int&gt;(<span class="number">5</span>, &#123;<span class="number">1</span>;<span class="number">2</span>;<span class="number">4</span>;<span class="number">2</span>;<span class="number">1</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>反编译之后如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLearningKt</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(@NotNull ClassLearning $receiver, @NotNull String str)</span> </span>&#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull($receiver, <span class="string">"$receiver"</span>);</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(str, <span class="string">"str"</span>);</span><br><span class="line">      $receiver.getArr()[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, <span class="string">"args"</span>);</span><br><span class="line">      ClassLearning l = <span class="keyword">new</span> ClassLearning(<span class="string">"oubin"</span>);</span><br><span class="line">      f(l, <span class="string">"f方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到被扩展的对象被打包成了receiver，然后就是这个对象直接操作他自身的元素了。也就是说，扩展对象并没有改变他们所扩展的类，而是通过生成另外一个方法来操作。所以我们可以发现，这个方法绝对是编译器生成的，所以对于运行期重载的情况怕是用不了了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">open class C</span><br><span class="line"></span><br><span class="line">class D: C()</span><br><span class="line"></span><br><span class="line">fun C.foo() = &quot;c&quot;</span><br><span class="line"></span><br><span class="line">fun D.foo() = &quot;d&quot;</span><br><span class="line"></span><br><span class="line">fun printFoo(c: C) &#123;</span><br><span class="line">    println(c.foo())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printFoo(D())  // 会print c</span><br></pre></td></tr></table></figure></p>
<p>2.扩展属性<br>扩展属性不能有初始化器，他们的行为只能由显式的getter和setter定义。扩展属性也是在新类中生成了一个get方法，然后将扩展属性的get()返回的值进行返回。</p>
<p>3.伴生对象扩展：同样伴生对象也可以定义扩展函数和属性。</p>
<h2 id="四-数据类"><a href="#四-数据类" class="headerlink" title="四.数据类"></a>四.数据类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data class Person(val name: String)&#123;</span><br><span class="line">    var age: Int = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun Person.copy(name:String = this.name) = Person(name)</span><br></pre></td></tr></table></figure>
<p>数据类可以将部分属性放入括号内，从而排除这些属性。进行copy的时候可以如上定义，然后Person对象可以直接调用copy函数</p>
<p>数据类的解构声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val jane = User(&quot;Jane&quot;, 35)</span><br><span class="line">val (name, age) = jane</span><br><span class="line">println(&quot;$name, $age years of age&quot;)</span><br></pre></td></tr></table></figure></p>
<p>他是使用了利用了componentN()函数。<br><img src="http://ovkwd4vse.bkt.clouddn.com/markdown-img-paste-20180410170358854.png" alt=""></p>
<h2 id="五-嵌套类"><a href="#五-嵌套类" class="headerlink" title="五.嵌套类"></a>五.嵌套类</h2><p>内部类通过标记为inner可以访问外部类的成员，因为会带有一个对外部类的对象的引用。</p>
<p>匿名内部类可以使用对象表达式来实现。</p>
<h2 id="六-对象"><a href="#六-对象" class="headerlink" title="六.对象"></a>六.对象</h2><p>1.对象表达式: 样式为 object: X(){…}<br>当我们不需要任何超类型时，就写做 val a = object{ val x = 3}, 这样我们就可以访问a.x<br>它的实现原理是通过new Object()去生成了这样一个对象并定义相关属性。</p>
<p>对象表达式可以访问外部的属性，并且比java匿名内部类更牛的是它不限制是final对象。</p>
<p>2.伴生对象<br>当我们在类中定义伴生对象时发生了什么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class HeritLearning(name: String) : ClassLearning(name)&#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val x: String = <span class="string">"ds"</span></span><br><span class="line"></span><br><span class="line">        <span class="function">fun <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            println()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反编译后为</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Companion</span> </span>&#123;</span><br><span class="line">      <span class="meta">@NotNull</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> HeritLearning.x;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Companion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// $FF: synthetic method</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Companion</span><span class="params">(DefaultConstructorMarker $constructor_marker)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们的companion被编译成了一个静态内部类，属性被定义为外部类的静态属性，而方法确是这个静态内部类的方法。由此，我们知道伴生方法是访问不了非伴生属性的。</p>
<h2 id="七-委托"><a href="#七-委托" class="headerlink" title="七.委托"></a>七.委托</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class <span class="title">BaseImpl</span><span class="params">(val x: Int)</span> : Base </span>&#123;</span><br><span class="line">    <span class="function">override fun <span class="title">print</span><span class="params">()</span> </span>&#123; print(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Derived(b: Base) : Base by b</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">    val b = BaseImpl(<span class="number">10</span>)</span><br><span class="line">    Derived(b).print() <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/08/Kotlin深入学习系列(一)：基础篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/Kotlin深入学习系列(一)：基础篇/" itemprop="url">Kotlin深入学习系列(一):基础篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-08T20:08:01+08:00">
                2018-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>1.数字<br>数字与java中基本相同，主要是下面几点不同：</p>
<ul>
<li>kotlin对于数字没有隐式扩展转换(如从int转为long)</li>
<li>在kotlin中字符不是数字</li>
</ul>
<p>2.表示方式<br>kotlin会把数字存储为jvm的原生类型，但是只有在<strong>需要可空引用或泛型时</strong>数字会被装箱。<br>但是这里存在着一个坑：当取值在[-128, 127]之间时不会被装箱，而在这之外的int数字才会被装箱，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val b:Int = 5    // 被编译为 short b = 5;</span><br><span class="line">val b1:Int? = b  // 被编译为 Integer i = Integer.valueOf(5)</span><br><span class="line">val b11:Int? = b  </span><br><span class="line">println(b1 === b11) // 注意这里打印的是 &apos;true&apos;  </span><br><span class="line"></span><br><span class="line">val a: Int = 10000  </span><br><span class="line">val a1: Int? = a  </span><br><span class="line">val a11: Int? = a  </span><br><span class="line">println (a1 === a11 ) //注意这里打印的是 &apos;false&apos;</span><br></pre></td></tr></table></figure></p>
<p>这是因为JVM把[-128,127]的所有int数字的装箱全部缓存了，任何指向这个范围的对象，都不可能被另外”创建”，应该是为了缓存最常用的数字以节省性能吧。</p>
<p>3.在kotlin中万物皆对象，=== 是比较对象之间的地址是否相等， == 是比较对象的大小是否相等。</p>
<p>4.数据类型转换：需要使用toByte(),toInt之类的转换。</p>
<p>5.浮点数比较有些很棒的特性：</p>
<ul>
<li>区间实例以及区间检测：a..b、 x in a..b、 x !in a..b。 这里可以使用两个点来表示，甚至比python更方便。</li>
<li>NaN与其自身相等，而且比任何其他元素都大</li>
</ul>
<p>6.字符Char不能直接当做数字，用单引号，与java一样。并且当需要可空引用时也会被装箱。</p>
<p>7.数组：数组直接用Array<t>表示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一.已知所有元素</span></span><br><span class="line">val a = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// array[1,2,3]</span></span><br><span class="line">val b = Array(<span class="number">5</span>, &#123; i -&gt; (i * i).toString() &#125;)  <span class="comment">// 数组大小和一个Array构造函数</span></span><br><span class="line"><span class="comment">// 二.空数组</span></span><br><span class="line">val c = emptyArray()/ arrayOfNulls&lt;String&gt;(<span class="number">0</span>)  <span class="comment">// 创建一个长度为0的null数组</span></span><br><span class="line"><span class="comment">// 三.基本类型</span></span><br><span class="line">val d = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)  <span class="comment">// 对于基本类型数组有特殊优化，但是得到的IntArray并不是Array的子类。</span></span><br><span class="line"><span class="comment">// 四.创建一个已知数量的数组</span></span><br><span class="line">val a = arrayOfNulls&lt;String&gt;(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></t></p>
<p>kotlin中数组是invariant的，不能把Array<string>赋值给Array<any>,但是可以是Array<out any=""></out></any></string></p>
<p>8.字符串模板<br>字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。模板表达式以美元符（$）开头，由一个简单的名字构成。如果要直接输出$符，只要不加变量即可:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val s = <span class="string">"abc"</span></span><br><span class="line">println(<span class="string">"$s.length is $&#123;s.length&#125;"</span>) <span class="comment">// 输出“abc.length is 3”</span></span><br><span class="line">print(<span class="string">"$8.8"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>1.if语句表达三元运算符：val max = if (a &gt; b) a else b。与python中的表达十分相似：max = a if a &gt; b else b</p>
<p>2.When表达式<br>when是一个加强的switch语句，可以作为语句也可以作为表达式。可以替代if else if链<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun hasPrefix(x: Any) = when(x) &#123;</span><br><span class="line">    1,2 -&gt; true</span><br><span class="line">    is String -&gt; x.startsWith(&quot;prefix&quot;)</span><br><span class="line">    else -&gt; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.for可以循环任何提供了迭代器的对象。</p>
<p>4.Kotlin中任何表达式都可以用标签(label)来标记。标签的格式为标识符后跟@符号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop@ for (i in 1..100) &#123;</span><br><span class="line">    for (j in 1..100) &#123;</span><br><span class="line">        if (……) break@loop</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例子中的break可以直接跳出两重循环。同样的return,continue都可以使用这种操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">oubindo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">oubindo</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
