<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="gradle," />










<meta name="description" content="一篇文章深入gradle（上篇）:依赖机制Hello，各位朋友们，小笨鸟又和你们见面啦。不同于网上泛泛而谈的入门文章只停留在“怎么用”的层次，本篇文章从源码角度去理解gradle。当然，如果你没有看过我的前一篇文章《一篇文章基本看懂gradle》，还是建议你先看一下，本篇文章的很多知识点会在上篇文章的基础上展开。 本篇文章会比较深入，需要费一些脑筋和精力才能理解。建议跟着我的行文思路一步一步理解。">
<meta name="keywords" content="gradle">
<meta property="og:type" content="article">
<meta property="og:title" content="一篇文章深入gradle（上篇）:依赖机制">
<meta property="og:url" content="http://yoursite.com/2019/09/05/一篇文章深入gradle/index.html">
<meta property="og:site_name" content="Coding and Learning">
<meta property="og:description" content="一篇文章深入gradle（上篇）:依赖机制Hello，各位朋友们，小笨鸟又和你们见面啦。不同于网上泛泛而谈的入门文章只停留在“怎么用”的层次，本篇文章从源码角度去理解gradle。当然，如果你没有看过我的前一篇文章《一篇文章基本看懂gradle》，还是建议你先看一下，本篇文章的很多知识点会在上篇文章的基础上展开。 本篇文章会比较深入，需要费一些脑筋和精力才能理解。建议跟着我的行文思路一步一步理解。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190904002104.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190904101030.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190905001835.png">
<meta property="og:updated_time" content="2019-09-15T02:29:08.432Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一篇文章深入gradle（上篇）:依赖机制">
<meta name="twitter:description" content="一篇文章深入gradle（上篇）:依赖机制Hello，各位朋友们，小笨鸟又和你们见面啦。不同于网上泛泛而谈的入门文章只停留在“怎么用”的层次，本篇文章从源码角度去理解gradle。当然，如果你没有看过我的前一篇文章《一篇文章基本看懂gradle》，还是建议你先看一下，本篇文章的很多知识点会在上篇文章的基础上展开。 本篇文章会比较深入，需要费一些脑筋和精力才能理解。建议跟着我的行文思路一步一步理解。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190904002104.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/05/一篇文章深入gradle/"/>





  <title>一篇文章深入gradle（上篇）:依赖机制 | Coding and Learning</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coding and Learning</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">oubindo的技术与生活博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/05/一篇文章深入gradle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="oubindo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding and Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">一篇文章深入gradle（上篇）:依赖机制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-05T21:30:44+08:00">
                2019-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一篇文章深入gradle（上篇）-依赖机制"><a href="#一篇文章深入gradle（上篇）-依赖机制" class="headerlink" title="一篇文章深入gradle（上篇）:依赖机制"></a>一篇文章深入gradle（上篇）:依赖机制</h2><p>Hello，各位朋友们，小笨鸟又和你们见面啦。不同于网上泛泛而谈的入门文章只停留在“怎么用”的层次，本篇文章从源码角度去理解gradle。当然，如果你没有看过我的前一篇文章《一篇文章基本看懂gradle》，还是建议你先看一下，本篇文章的很多知识点会在上篇文章的基础上展开。</p>
<p>本篇文章会比较深入，需要费一些脑筋和精力才能理解。建议跟着我的行文思路一步一步理解。本文的篇幅会比较长。阅读大概需要花费半个小时。阅读本文将会了解:</p>
<ul>
<li>gradle构建Lifecycle</li>
<li>gradle Extension和Plugin</li>
<li>gradle依赖实现，Configuration</li>
</ul>
<p>其中gradle依赖将会是本文的重点。本来之前还想把artifact也讲解到，但是发现篇幅已经很长了，所以就一篇文章拆成两篇吧。</p>
<h2 id="gradle构建Lifecycle"><a href="#gradle构建Lifecycle" class="headerlink" title="gradle构建Lifecycle"></a>gradle构建Lifecycle</h2><p>Lifecycle的概念我们在上一篇文章讲Project的时候也讲到过。在这篇文章中，我们会再简单讲一讲作为引入。</p>
<p>正如<a href="https://docs.gradle.org/current/userguide/build_lifecycle.html" target="_blank" rel="noopener">官网</a>所说，gradle构建流程总共为三个阶段：</p>
<ul>
<li>初始化阶段：在这个阶段中settings.gradle是主角，gradle会把settings.gradle中的配置代理给Settings类。主要负责的是判断哪些module需要参与到构建中，然后根据这些module的设置初始化他们的delegate对象Project。注意，Project对象是在初始化阶段生成的。</li>
<li>配置阶段：配置阶段的任务是执行各项目下的build.gradle，完成Project对象的配置，并且构造Task任务依赖关系图<code>TaskExectionGraph</code>以便在执行阶段按照依赖关系执行Task。</li>
<li>执行阶段：执行阶段会根据你命令行输入的Task，按照依赖关系通过调用<code>gradle taskname</code>进行执行。</li>
</ul>
<p>值得一提的是，我们可以通过多种方式对project构建阶段进行监控和处理。如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下为Project的方法</span></span><br><span class="line">afterEvaluate(closure)，afterEvaluate(action)</span><br><span class="line">beforeEvaluate(closure)，beforeEvaluate(action)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为gradle提供的生命周期回调</span></span><br><span class="line">afterProject(closure)，afterProject(action)</span><br><span class="line">beforeProject(closure)，beforeProject(action)</span><br><span class="line">buildFinished(closure)，buildFinished(action)</span><br><span class="line">projectsEvaluated(closure)，projectsEvaluated(action)</span><br><span class="line">projectsLoaded(closure)，projectsLoaded(action)</span><br><span class="line">settingsEvaluated(closure)，settingsEvaluated(action)</span><br><span class="line">addBuildListener(buildListener)</span><br><span class="line">addListener(listener)</span><br><span class="line">addProjectEvaluationListener(listener)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Task也有这种方法</span></span><br><span class="line">afterTask​(Closure closure)</span><br><span class="line">beforeTask(Closure closure)</span><br><span class="line"><span class="comment">//任务准备好后调用</span></span><br><span class="line">whenReady(Closure closure)</span><br></pre></td></tr></table></figure></p>
<p>那么知道这样的构建流程我们可以怎么使用呢？我们可以进行监控，或者是动态的根据需要去控制project和task的构建执行。比如为了加快编译速度，我们去掉一些测试的task。就可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gradle.taskGraph.whenReady &#123;</span><br><span class="line">        tasks.each &#123; task -&gt;</span><br><span class="line">            if (task.name.contains(&quot;Test&quot;)) &#123;</span><br><span class="line">                task.enabled = false</span><br><span class="line">            &#125; else if (task.name == &quot;mockableAndroidJar&quot;) &#123;</span><br><span class="line">                task.enabled = false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Extension和Plugin"><a href="#Extension和Plugin" class="headerlink" title="Extension和Plugin"></a>Extension和Plugin</h2><p>Extension和Plugin都是我们日常开发中经常有讲到的东西。上一篇文章中我们讲到了build.gradle中的闭包都是有一个Delegate代理的，这个代理对象可以接受闭包中的参数传递给自己来使用，那么这个代理是啥呢？其实就是我们这里要说的Extension。</p>
<p>1.Extension通俗来讲其实就是一个普通的java bean。里面存放一些参数。使用需要借助于ExtensionContainer来进行创建。举个栗子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    String message = <span class="string">"empty"</span></span><br><span class="line">    String greeter = <span class="string">"none"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来在gradle文件中去使用project.extensions(也就是ExtensionContainer)来进行创建。</span></span><br><span class="line">def extension = project.extensions.create(<span class="string">"cyMessage"</span>, Message)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再写个task来进行验证</span></span><br><span class="line">project.task(<span class="string">'sendMessage'</span>) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"$&#123;extension.message&#125; from $&#123;extension.greeter&#125;"</span></span><br><span class="line">        println project.cyMessage.message + <span class="string">"from $&#123;extension.greeter&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.Plugin插件<br>讲完了Extension，我们可能就会疑惑了。因为我们在build.gradle中并没有看到这些javabean和extension添加的操作啊，那么这些代码是在哪里写的呢？这时候我们就要引入Plugin的概念了，也就是你看到的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin &apos;com.android.application&apos;</span><br></pre></td></tr></table></figure></p>
<p>这个玩意了。这个就是Android Application的插件。android相关的Extension都是定义在这个插件中的。<br>有些同学可能对插件不是很理解，为什么需要这个东西。其实大家可以思考一下，gradle只是一个通用的构建工具。在他上层可能有各种应用，比如java，比如Android，甚至可能是未来的鸿蒙。那么这些应用对gradle肯定会有不同的扩展，又肯定不能把这些扩展直接放在gradle中。所以在上层添加插件就是个好选择，需要什么扩展就选什么插件。<br>Android开发中常见的插件有三种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apply plugin &apos;com.android.application&apos;   // AppPlugin,  主module才能引用</span><br><span class="line">apply plugin &apos;com.android.library&apos;    // LibraryPlugin, 普通的android module引用</span><br><span class="line">apply plugin &apos;java&apos;                           // java module的引用</span><br></pre></td></tr></table></figure></p>
<p>插件的其它知识不是本篇文章的重点，网上这方面的文章很多，大家可以自行学习。我们根据现在掌握的知识就要去探索gradle更深层次的知识啦。</p>
<h2 id="gradle依赖实现"><a href="#gradle依赖实现" class="headerlink" title="gradle依赖实现"></a>gradle依赖实现</h2><p>这两篇文章截止到现在，gradle构建相关的流程我们基本都走通了。但是有个很重要的组件我们没有去分析。就是依赖管理。我们前一篇文章也讲到了，依赖管理是gradle的一个很重要的特性，方便我们进行代码复用。那么我们这一部分就专门讲一讲依赖管理到底是怎么实现的。</p>
<p>首先我们还是看看基本的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)</span><br><span class="line">    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;</span><br><span class="line">    api  &apos;com.android.support:appcompat-v7:26.1.0&apos;</span><br><span class="line">    implementation project(&apos;:test&apos;)</span><br><span class="line">    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;</span><br><span class="line">    annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.4.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，一般有三种三方库类型，第一种是二进制文件，fileTree指向这个文件夹下的所有jar文件，第二种是三方库的string坐标形式，第三种是project的形式。<br>当然，我们也会知道，代码中的implementation和api两种引用方式是有区别的。implement的依赖是不能传递的，但是api是可以的。</p>
<p>我们在之前的研发中，可能没有去考虑深层次的这三种三方库类型，两种引用方式的原因。当我们按照上一篇中所说的代理模式去DependencyHandler中找implement, api等相关方法的时候，却发现，好像并没有定义这些方法，那么这是怎么回事呢？如果没有定义，是不是可以随便定义一种引用方式呢？带着问题我们往下面看</p>
<h3 id="1-源码阅读姿势"><a href="#1-源码阅读姿势" class="headerlink" title="1.源码阅读姿势"></a>1.源码阅读姿势</h3><p>首先我们还是先介绍一下阅读gradle源码的方式。我尝试了很多种方式，发现还是Android studio阅读起来最舒服，然后找到了一种方法。就是可以建一个gradle的demo，然后建一个module，把除了build.gradle以外的东西全部删掉。然后拷贝下面的代码进去。这样就能看到源码了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply plugin &apos;java&apos;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">     compile gradleApi()</span><br><span class="line">     compile &apos;xxxx&apos;  // 填入你gradle的版本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h3><h4 id="2-1-methodmissing"><a href="#2-1-methodmissing" class="headerlink" title="2.1 methodmissing"></a>2.1 methodmissing</h4><p>首先我们先介绍一个groovy语言的特性：methodmissing。大家可以参考<a href="http://groovy-lang.org/metaprogramming.html#_methodmissing" target="_blank" rel="noopener">官网</a><br>简单来说就是当我们预先在一个类中定义一个methodmissing方法。然后在这个类的对象上调用之前没有定义过的方法时，这个方法就会降级(fallback)到它所定义的methodmissing方法上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class GORM &#123;</span><br><span class="line"></span><br><span class="line">   def dynamicMethods = [...] // an array of dynamic methods that use regex</span><br><span class="line"></span><br><span class="line">   def methodMissing(String name, args) &#123;</span><br><span class="line">       def method = dynamicMethods.find &#123; it.match(name) &#125;</span><br><span class="line">       if(method) &#123;</span><br><span class="line">          GORM.metaClass.&quot;$name&quot; = &#123; Object[] varArgs -&gt;</span><br><span class="line">             method.invoke(delegate, name, varArgs)</span><br><span class="line">          &#125;</span><br><span class="line">          return method.invoke(delegate,name, args)</span><br><span class="line">       &#125;</span><br><span class="line">       else throw new MissingMethodException(name, delegate, args)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert new GORM().methodA(1) == resultA</span><br></pre></td></tr></table></figure></p>
<p>如图，当我们调用methodA时，因为这个方法没有定义，就会转到methodmissing方法上，并且会把这个方法的名字methodA和它的参数一起传到methodmissing，这样如果dynamicMethod里面有定义methodA的话，这个方法就能执行了。这就是methodmissing的妙用。</p>
<p>为什么需要这种机制呢？我理解这还是为了扩展性。dependencies是gradle自身的功能。它不能完全的总括所有上层应用可能会有的引用方式。每种插件都可能增加引用的方式，为了扩展性考虑，必须采用这种methodmissing的特性，把这些引用交给插件处理。比如Android的implement, api, annotationProcessor等。</p>
<h4 id="2-2-Configuration"><a href="#2-2-Configuration" class="headerlink" title="2.2 Configuration"></a>2.2 Configuration</h4><p>在往下面讲解前，我们先了解一下<a href="https://docs.gradle.org/current/userguide/managing_dependency_configurations.html" target="_blank" rel="noopener">Configuration</a>的一些知识。<br>按照官网所说：</p>
<blockquote>
<p>Every dependency declared for a Gradle project applies to a specific scope. For example some dependencies should be used for compiling source code whereas others only need to be available at runtime. Gradle represents the scope of a dependency with the help of a Configuration. Every configuration can be identified by a unique name.</p>
</blockquote>
<p>也就是说，Configuration定义了依赖在编译和运行时候的不同范围, 每个Configuration都有name来区分。比如android常见的两种依赖方式implementation和api。<br><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190904002104.png" alt="">。</p>
<h4 id="2-3-依赖的识别"><a href="#2-3-依赖的识别" class="headerlink" title="2.3 依赖的识别"></a>2.3 依赖的识别</h4><p>gradle中使用MethodMixIn这个接口来实现methodmissing的能力。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MethodMixIn</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodMixIn</span> </span>&#123;</span><br><span class="line">    <span class="function">MethodAccess <span class="title">getAdditionalMethods</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodAccess</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true when this object is known to have a method with the given name that accepts the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that not every method is known. Some methods may require an attempt invoke it in order for them to be discovered.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasMethod</span><span class="params">(String name, Object... arguments)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invokes the method with the given name and arguments.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">DynamicInvokeResult <span class="title">tryInvokeMethod</span><span class="params">(String name, Object... arguments)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里的methodmissing主要是在找不到这个方法的时候去返回一个MethodAccess，MethodAccess中去判断是否存在以及动态执行这个method。</p>
<p>接下来我们看DependencyHandler的实现类DefaultDependencyHandler。这个类实现了MethodMixIn接口，返回的是一个DynamicAddDependencyMethods对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultDependencyHandler.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultDependencyHandler</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.dynamicMethods = <span class="keyword">new</span> DynamicAddDependencyMethods(configurationContainer, <span class="keyword">new</span> DefaultDependencyHandler.DirectDependencyAdder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodAccess <span class="title">getAdditionalMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dynamicMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以其实就是返回了一个DynamicAddDependencyMethods去加以判断。那么毫无疑问要在这个类中进行判断和执行具体方法。接下来我们看看这个类中是怎么处理的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">DynamicAddDependencyMethods(ConfigurationContainer configurationContainer, DynamicAddDependencyMethods.DependencyAdder dependencyAdder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.configurationContainer = configurationContainer;</span><br><span class="line">    <span class="keyword">this</span>.dependencyAdder = dependencyAdder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMethod</span><span class="params">(String name, Object... arguments)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arguments.length != <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.configurationContainer.findByName(name) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DynamicInvokeResult <span class="title">tryInvokeMethod</span><span class="params">(String name, Object... arguments)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arguments.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> DynamicInvokeResult.notFound();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Configuration configuration = (Configuration)<span class="keyword">this</span>.configurationContainer.findByName(name);</span><br><span class="line">        <span class="keyword">if</span> (configuration == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> DynamicInvokeResult.notFound();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;?&gt; normalizedArgs = CollectionUtils.flattenCollections(arguments);</span><br><span class="line">            <span class="keyword">if</span> (normalizedArgs.size() == <span class="number">2</span> &amp;&amp; normalizedArgs.get(<span class="number">1</span>) <span class="keyword">instanceof</span> Closure) &#123;</span><br><span class="line">                <span class="keyword">return</span> DynamicInvokeResult.found(<span class="keyword">this</span>.dependencyAdder.add(configuration, normalizedArgs.get(<span class="number">0</span>), (Closure)normalizedArgs.get(<span class="number">1</span>)));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizedArgs.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> DynamicInvokeResult.found(<span class="keyword">this</span>.dependencyAdder.add(configuration, normalizedArgs.get(<span class="number">0</span>), (Closure)<span class="keyword">null</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Iterator var5 = normalizedArgs.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">                    Object arg = var5.next();</span><br><span class="line">                    <span class="keyword">this</span>.dependencyAdder.add(configuration, arg, (Closure)<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> DynamicInvokeResult.found();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这个类的两个要点：<br>1.判断Configuration有无：通过外部传入的ConfigurationContainer来判断是否存在这个方法。<strong>这样我们可以联想到，这个ConfigurationContainer肯定是每个平台Plugin自己传入的，必须是已定义的才能使用</strong>。比如android就添加了implementation, api等。如果你想查看Configuration在gradle源码中的初始化和配置，可以查看VariantDependencies这个类。</p>
<p>2.执行方法：真正的执行方法会根据参数来判断，比如我们常见的一个参数的引用形式，还有一个参数+一个闭包的形式，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'com.zhyea:ar4j:1.0'</span>) &#123;</span><br><span class="line">		exclude <span class="keyword">module</span>: <span class="string">'cglib'</span> <span class="comment">//by artifact name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种类型的引用。当在ConfigurationContainer中找到了这个引用方式(以下都称Configuration)时，就会返回一个DynamicInvokeResult。具体这个类的作用我们后面再看，我们先看他们都做了一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.dependencyAdder.add(configuration, arg, (Closure)<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>的操作，这个操作是做了些什么呢，我们继续往下跟就会发现，其实还是调用了DefaultDependencyHandler的doAdd方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultDependencyHandler.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectDependencyAdder</span> <span class="keyword">implements</span> <span class="title">DependencyAdder</span>&lt;<span class="title">Dependency</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DirectDependencyAdder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dependency <span class="title">add</span><span class="params">(Configuration configuration, Object dependencyNotation, @Nullable Closure configureAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DefaultDependencyHandler.<span class="keyword">this</span>.doAdd(configuration, dependencyNotation, configureAction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Dependency <span class="title">doAdd</span><span class="params">(Configuration configuration, Object dependencyNotation, Closure configureClosure)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dependencyNotation <span class="keyword">instanceof</span> Configuration) &#123;</span><br><span class="line">        Configuration other = (Configuration)dependencyNotation;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.configurationContainer.contains(other)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Currently you can only declare dependencies on configurations from the same project."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            configuration.extendsFrom(<span class="keyword">new</span> Configuration[]&#123;other&#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Dependency dependency = <span class="keyword">this</span>.create(dependencyNotation, configureClosure);</span><br><span class="line">        configuration.getDependencies().add(dependency);</span><br><span class="line">        <span class="keyword">return</span> dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里会先判断dependencyNotation是否是Configuration，如果存在的话，就让当前的configuration继承dependencyNotation，也就是所有添加到dependencyNotation的依赖都会添加到configuration中。</p>
<p>这里可能有些朋友就会疑惑了，为啥还要对dependencyNotation判断呢？这个主要是为了处理嵌套的情况。比如implementation project(path: ‘:projectA’, configuration: ‘configA’)这种类型的引用。有兴趣可以看看上面的<code>CollectionUtils.flattenCollections(arguments)</code>方法。</p>
<p>总结一下，这个过程就是借助gradle的MethodMixIn接口，将所有未定义的引用方法转到getAdditionalMethods方法上来，在这个方法里面判断Configuration是否存在，如果存在的话就生成Dependency。</p>
<h4 id="2-4-依赖的创建"><a href="#2-4-依赖的创建" class="headerlink" title="2.4 依赖的创建"></a>2.4 依赖的创建</h4><p>可以看到上面过程的最后，是DefaultDependencyHandler调用了create方法创建出了一个Dependency。我们继续来分析创建Dependency的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultDependencyHandler.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dependency <span class="title">create</span><span class="params">(Object dependencyNotation, Closure configureClosure)</span> </span>&#123;</span><br><span class="line">    Dependency dependency = <span class="keyword">this</span>.dependencyFactory.createDependency(dependencyNotation);</span><br><span class="line">    <span class="keyword">return</span> (Dependency)ConfigureUtil.configure(configureClosure, dependency);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultDependencyFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dependency <span class="title">createDependency</span><span class="params">(Object dependencyNotation)</span> </span>&#123;</span><br><span class="line">    Dependency dependency = (Dependency)<span class="keyword">this</span>.dependencyNotationParser.parseNotation(dependencyNotation);</span><br><span class="line">    <span class="keyword">this</span>.injectServices(dependency);</span><br><span class="line">    <span class="keyword">return</span> dependency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最终是调用了dependencyNotationParser来parse这个dependencyNotation。而这里的dependencyNotationParser其实就是DependencyNotationParser这个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyNotationParser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NotationParser&lt;Object, Dependency&gt; <span class="title">parser</span><span class="params">(Instantiator instantiator, DefaultProjectDependencyFactory dependencyFactory, ClassPathRegistry classPathRegistry, FileLookup fileLookup, RuntimeShadedJarFactory runtimeShadedJarFactory, CurrentGradleInstallation currentGradleInstallation, Interner&lt;String&gt; stringInterner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NotationParserBuilder.toType(Dependency.class)</span><br><span class="line">        .fromCharSequence(<span class="keyword">new</span> DependencyStringNotationConverter(instantiator, DefaultExternalModuleDependency.class, stringInterner))</span><br><span class="line">        .converter(<span class="keyword">new</span> DependencyMapNotationConverter(instantiator, DefaultExternalModuleDependency.class))</span><br><span class="line">        .fromType(FileCollection.class, <span class="keyword">new</span> DependencyFilesNotationConverter(instantiator))</span><br><span class="line">        .fromType(Project.class, <span class="keyword">new</span> DependencyProjectNotationConverter(dependencyFactory))</span><br><span class="line">        .fromType(ClassPathNotation.class, <span class="keyword">new</span> DependencyClassPathNotationConverter(instantiator, classPathRegistry, fileLookup.getFileResolver(), runtimeShadedJarFactory, currentGradleInstallation))</span><br><span class="line">        .invalidNotationMessage(<span class="string">"Comprehensive documentation on dependency notations is available in DSL reference for DependencyHandler type."</span>).toComposite();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从里面我们看到了FileCollection，Project，ClassPathNotation三个类，是不是感觉和我们的三种三方库资源形式很对应？其实这三种资源形式的解析就是用这三个类进行的。DependencyNotationParser就是整合了这些转换器，成为一个综合的转换器。其中，</p>
<ul>
<li>DependencyFilesNotationConverter将FileCollection解析为SelfResolvingDependency，也就是implementation fileTree(include: [‘*.jar’], dir: ‘libs’)这种形式。</li>
<li>DependencyProjectNotationConverter将Project解析为ProjectDependency。也就是implementation project(‘:projectA’)</li>
<li>DependencyClassPathNotationConverter将ClassPathNotation转成SelfResolvingDependency。也就是implementation ‘xxx’这种。</li>
</ul>
<p>这三种方式具体的解析方法大家可以自行阅读源码，不是本文重点。所以除了Project会被解析为ProjectDependency以外，其他的都是SelfResolvingDependency。其实ProjectDependency是SelfResolvingDependency的子类。他们的关系可以从SelfResolvingDependency的代码注释中看出。</p>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190904101030.png" alt=""></p>
<h4 id="2-5-ProjectDependency"><a href="#2-5-ProjectDependency" class="headerlink" title="2.5 ProjectDependency"></a>2.5 ProjectDependency</h4><p>接下来讲讲ProjectDependency.一个常见的Project引用如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation project(‘:projectA’)</span><br></pre></td></tr></table></figure></p>
<p>这里的implementation我们已经知道是插件添加的扩展，不是gradle自带的。那project呢？这个就是gradle自带的了。delegate是DependencyHandler的project方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultDependencyHandler.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dependency <span class="title">project</span><span class="params">(Map&lt;String, ?&gt; notation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dependencyFactory.createProjectDependencyFromMap(<span class="keyword">this</span>.projectFinder, notation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultDependencyFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProjectDependency <span class="title">createProjectDependencyFromMap</span><span class="params">(ProjectFinder projectFinder, Map&lt;? extends String, ? extends Object&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.projectDependencyFactory.createFromMap(projectFinder, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProjectDependencyFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProjectDependency <span class="title">createFromMap</span><span class="params">(ProjectFinder projectFinder, Map&lt;? extends String, ?&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ProjectDependency)NotationParserBuilder.toType(ProjectDependency.class).converter(<span class="keyword">new</span> ProjectDependencyFactory.ProjectDependencyMapNotationConverter(projectFinder, <span class="keyword">this</span>.factory)).toComposite().parseNotation(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProjectDependencyMapNotationConverter.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ProjectDependency <span class="title">parseMap</span><span class="params">(@MapKey(<span class="string">"path"</span>)</span> String path, @Optional @<span class="title">MapKey</span><span class="params">(<span class="string">"configuration"</span>)</span> String configuration) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.factory.create(<span class="keyword">this</span>.projectFinder.getProject(path), configuration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultProjectDependencyFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProjectDependency <span class="title">create</span><span class="params">(ProjectInternal project, String configuration)</span> </span>&#123;</span><br><span class="line">    DefaultProjectDependency projectDependency = (DefaultProjectDependency)<span class="keyword">this</span>.instantiator.newInstance(DefaultProjectDependency.class, <span class="keyword">new</span> Object[]&#123;project, configuration, <span class="keyword">this</span>.projectAccessListener, <span class="keyword">this</span>.buildProjectDependencies&#125;);</span><br><span class="line">    projectDependency.setAttributesFactory(<span class="keyword">this</span>.attributesFactory);</span><br><span class="line">    projectDependency.setCapabilityNotationParser(<span class="keyword">this</span>.capabilityNotationParser);</span><br><span class="line">    <span class="keyword">return</span> projectDependency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，传入的project最终传递给了ProjectDependencyMapNotationConverter。先去查找这个project，然后通过factory去create ProjectDependency对象，当然这里也有考虑到Configuration的影响, 最终是产生了一个DefaultProjectDependency。这就是ProjectDependency的产生过程。</p>
<h4 id="2-6-依赖的体现"><a href="#2-6-依赖的体现" class="headerlink" title="2.6 依赖的体现"></a>2.6 依赖的体现</h4><p>看到这里，大家可以已经理解了不同的依赖的解析方式，但是可能还是不理解依赖到底是一个什么东西。<strong>其实依赖库并不是依赖三方库的源代码，而是依赖三方库的产物，产物又是通过一系列的Task执行产生的</strong>。也就是说，projectA依赖projectB，那么A就拥有了对于B的产物的所有权。关于产物我们等后面再介绍。先了解一下Configuration对于产物有一些什么支持。<br>我们看Configuration的代码， 可以发现他继承了FileCollection接口，而FileCollection又继承了Buildable接口。这个接口有啥用呢，用处大得很。先看<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Buildable.html" target="_blank" rel="noopener">官网</a>介绍</p>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190905001835.png" alt=""></p>
<p>Buildable表示着很多Task对象生成的产物。它里面只有一个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Buildable</span> </span>&#123;</span><br><span class="line">    <span class="function">TaskDependency <span class="title">getBuildDependencies</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看看DefaultProjectDependency的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultProjectDependency.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TaskDependencyInternal <span class="title">getBuildDependencies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultProjectDependency.TaskDependencyImpl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskDependencyImpl</span> <span class="keyword">extends</span> <span class="title">AbstractTaskDependency</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TaskDependencyImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitDependencies</span><span class="params">(TaskDependencyResolveContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DefaultProjectDependency.<span class="keyword">this</span>.buildProjectDependencies) &#123;</span><br><span class="line">            DefaultProjectDependency.<span class="keyword">this</span>.projectAccessListener.beforeResolvingProjectDependency(DefaultProjectDependency.<span class="keyword">this</span>.dependencyProject);</span><br><span class="line">            Configuration configuration = DefaultProjectDependency.<span class="keyword">this</span>.findProjectConfiguration();</span><br><span class="line">            context.add(configuration);</span><br><span class="line">            context.add(configuration.getAllArtifacts());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">findProjectConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConfigurationContainer dependencyConfigurations = <span class="keyword">this</span>.getDependencyProject().getConfigurations();</span><br><span class="line">    String declaredConfiguration = <span class="keyword">this</span>.getTargetConfiguration();</span><br><span class="line">    Configuration selectedConfiguration = dependencyConfigurations.getByName((String)GUtil.elvis(declaredConfiguration, <span class="string">"default"</span>));</span><br><span class="line">    <span class="keyword">if</span> (!selectedConfiguration.isCanBeConsumed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationNotConsumableException(<span class="keyword">this</span>.dependencyProject.getDisplayName(), selectedConfiguration.getName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> selectedConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，其实就是在解析每个依赖的时候，如果指定了ConfigurationContainer中声明好的Configuration，比如implementation, api等，那就返回这个Configuration，否则就返回default。拿到这个Configuration之后，做了这个操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.add(configuration);</span><br><span class="line">context.add(configuration.getAllArtifacts());</span><br></pre></td></tr></table></figure></p>
<p>这里的context是一个TaskDependencyResolveContext，它的add方法可以添加能contribute tasks to the result的对象，比如Task，TaskDependencies，Buildable等，这些类型都能为产生结果贡献Task(前面我们说到了就是靠Task产生产物的嘛)。 </p>
<p>这里context把configuration和configuration.getAllArtifacts()加入，都是作为Buildable而加入。区别是configuration.getAllArtifacts()获取的是DefaultPublishArtifactSet对象。接下来看看DefaultPublishArtifactSet是怎么实现Buildable的方法的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TaskDependency <span class="title">getBuildDependencies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.builtBy;   <span class="comment">// 这里的builtBy是下面的ArtifactsTaskDependency对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ArtifactsTaskDependency</span> <span class="keyword">extends</span> <span class="title">AbstractTaskDependency</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ArtifactsTaskDependency</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitDependencies</span><span class="params">(TaskDependencyResolveContext context)</span> </span>&#123;</span><br><span class="line">        Iterator var2 = DefaultPublishArtifactSet.<span class="keyword">this</span>.iterator();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">            PublishArtifact publishArtifact = (PublishArtifact)var2.next();</span><br><span class="line">            context.add(publishArtifact);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现果然和DefaultPublishArtifactSet的名字一样，是作为set把里面包含的PublishArtifact对象逐个的放入context中。</p>
<h4 id="2-7-总结"><a href="#2-7-总结" class="headerlink" title="2.7 总结"></a>2.7 总结</h4><p>我们在这一小节中分析了不同的依赖方式的区别，告诉了大家Configuration是什么东西，也告诉了大家依赖到底是怎么产生和起作用的。这样大家在日常开发中就更能知其所以然了。总结一下就是说</p>
<ul>
<li>implementation等都是通过methodmissing机制，被插件解析成不同的Configuration，所以要预定义。</li>
<li>我们不同的依赖声明，将会被不同的转化器Parser进行转换。project依赖会被转换为ProjectDependency，其余的会被解析成可自解析的SelfResolvingDependencies。</li>
<li>project依赖最终是Task和产物artifact的依赖。</li>
</ul>
<p>那么Task和产物又是一种什么关系呢？这个就涉及到更深层次了。本文篇幅有限，放在下一篇再分析吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是从Extension和Plugin引入，主要讲解了gradle依赖的原理和解析机制，然后抛下了一个疑问：产物artifacts是怎么和依赖扯上关系的呢？这个问题我们等下一篇《一篇文章深入gradle（下篇）:Artifacts》再解答</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/gradle/" rel="tag"># gradle</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/30/一篇文章看懂gradle/" rel="next" title="一篇文章基本看懂gradle">
                <i class="fa fa-chevron-left"></i> 一篇文章基本看懂gradle
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">oubindo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一篇文章深入gradle（上篇）-依赖机制"><span class="nav-number">1.</span> <span class="nav-text">一篇文章深入gradle（上篇）:依赖机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gradle构建Lifecycle"><span class="nav-number">2.</span> <span class="nav-text">gradle构建Lifecycle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Extension和Plugin"><span class="nav-number">3.</span> <span class="nav-text">Extension和Plugin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gradle依赖实现"><span class="nav-number">4.</span> <span class="nav-text">gradle依赖实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-源码阅读姿势"><span class="nav-number">4.1.</span> <span class="nav-text">1.源码阅读姿势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-源码分析"><span class="nav-number">4.2.</span> <span class="nav-text">2.源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-methodmissing"><span class="nav-number">4.2.1.</span> <span class="nav-text">2.1 methodmissing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-Configuration"><span class="nav-number">4.2.2.</span> <span class="nav-text">2.2 Configuration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-依赖的识别"><span class="nav-number">4.2.3.</span> <span class="nav-text">2.3 依赖的识别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-依赖的创建"><span class="nav-number">4.2.4.</span> <span class="nav-text">2.4 依赖的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-ProjectDependency"><span class="nav-number">4.2.5.</span> <span class="nav-text">2.5 ProjectDependency</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-依赖的体现"><span class="nav-number">4.2.6.</span> <span class="nav-text">2.6 依赖的体现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-总结"><span class="nav-number">4.2.7.</span> <span class="nav-text">2.7 总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">oubindo</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
